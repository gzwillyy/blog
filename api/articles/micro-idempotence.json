{"title":"微服务 之 幂等性机制","uid":"9e30b559063f2ec93bec62f6225da283","slug":"micro-idempotence","date":"2023-01-11T06:16:21.000Z","updated":"2023-01-11T06:16:21.000Z","comments":true,"path":"api/articles/micro-idempotence.json","keywords":null,"cover":"https://images.unsplash.com/photo-1667372459567-3853510dd5ce","content":"<h2 id=\"http请求的类型：\"><a href=\"#http请求的类型：\" class=\"headerlink\" title=\"http请求的类型：\"></a>http请求的类型：</h2><ul>\n<li><code>get</code> 获取商品信息， 这个会引起商品的数据的变化吗？</li>\n<li><code>post</code> 比较常见，这种接口需要考虑到幂等性</li>\n<li><code>put</code><ul>\n<li>没有幂等的问题的情况：把1号商品的价格改为200，网络返回的时候抖动了，重试 ,第二次接口还是会把1号商品的价格改为200 </li>\n<li>出现幂等性问题的情况：<ul>\n<li>购物车中的商品，调用一次 这个商品的数量加一</li>\n<li>第一次调用 原本的值 10 之后价格变为11 - 但是返回的时候出现了网络抖动 </li>\n<li>第二次发送 原本的值 11 之后价格变为12 - 但是返回的时候出现了网络抖动，</li>\n<li>第三次发送 原本的值 12 之后价格变为13 - 但是返回的时候出现了网络抖动</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>delete</code> 一般不具备幂等性的要求，第一次调用 删除数据，第二次调用 还是删除当前的数据</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>现在假设，你自己开发了一个支付宝，然后别人在二维码支付页面，先支付了,<br>结果由于网络问题，当前页面一直没有刷新，就让人以为我没有支付，然后我就再次扫码支付，这下完蛋了：你扣了两次款。</p></blockquote>\n<h2 id=\"超时-重试-幂等性机制\"><a href=\"#超时-重试-幂等性机制\" class=\"headerlink\" title=\"超时 重试 幂等性机制\"></a>超时 重试 幂等性机制</h2><h3 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h3><p>  <code>timeout</code>是为了保护服务，避免<code>consumer</code>服务因为<code>provider</code> 响应慢而也变得响应很慢，这样<code>consumer</code>可以尽量保持原有的性能。</p>\n<h3 id=\"重试\"><a href=\"#重试\" class=\"headerlink\" title=\"重试\"></a>重试</h3><p>  如果<code>provider</code>只是偶尔抖动，那么超时后直接放弃，不做后续处理，就会导致当前请求错误，也会带来业务方面的损失。</p>\n<p>  对于这种偶尔抖动，可以在超时后重试一下，重试如果正常返回了，那么这次请求就被挽救了，能够正常给前端返回数据，只不过比原来响应慢一点。</p>\n<p>  重试可以考虑切换一台机器来进行调用，因为原来机器可能由于临时负载高而性能下降，重试会更加剧其性能问题，而换一台机器，得到更快返回的概率也更大一些。</p>\n<h3 id=\"幂等\"><a href=\"#幂等\" class=\"headerlink\" title=\"幂等\"></a>幂等</h3><p>  在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p>\n<p>  幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。</p>\n<p>  这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>\n<p>  <strong>例如：</strong> <code>getUsername()</code>和<code>setTrue()</code> 函数就是一个幂等函数. </p>\n<p>  <strong>更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</strong><br>  <strong>我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的</strong></p>\n<h2 id=\"常见的幂等性解决方案\"><a href=\"#常见的幂等性解决方案\" class=\"headerlink\" title=\"常见的幂等性解决方案\"></a>常见的幂等性解决方案</h2><p>  <strong>1. 查询操作：</strong> 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。<code>select</code>是天然的幂等操作  </p>\n<p>  <strong>2. 删除操作：</strong> 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回<code>0</code>，删除的数据多条，返回结果多个)  </p>\n<h3 id=\"数据库唯一索引，防止新增脏数据\"><a href=\"#数据库唯一索引，防止新增脏数据\" class=\"headerlink\" title=\"数据库唯一索引，防止新增脏数据\"></a>数据库唯一索引，防止新增脏数据</h3><p>  <strong>比如：</strong> 新建用户的时候将手机号码设置为唯一索引，那么即使你重试，也只会新建一个用户，不会因为重试导致当前用户注册了两个用户</p>\n<p>  <strong>要点：</strong> 唯一索引或唯一组合索引来防止新增数据存在脏数据 当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）  </p>\n<h3 id=\"token机制，防止页面重复提交\"><a href=\"#token机制，防止页面重复提交\" class=\"headerlink\" title=\"token机制，防止页面重复提交\"></a>token机制，防止页面重复提交</h3><ul>\n<li><p>业务要求：页面的数据只能被点击提交一次  </p>\n</li>\n<li><p>发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交  </p>\n</li>\n<li><p>解决办法：集群环境：采用<code>token</code>加<code>redis</code>（<code>redis</code>单线程的，处理需要排队） </p>\n</li>\n<li><p>处理流程：  </p>\n<ul>\n<li>数据提交前要向服务的申请<code>token</code>，<code>token</code>放到<code>redis</code>或<code>内存</code>，<code>token</code>有效时间 </li>\n<li>提交后后台校验<code>token</code>，同时删除<code>token</code>，生成新的<code>token</code>返回</li>\n</ul>\n</li>\n</ul>\n<p>  <strong>token特点：</strong> 要申请，一次有效性，可以限流<br>  <strong>注意：</strong> <code>redis</code>要用删除操作来判断<code>token</code>，删除成功代表<code>token</code>校验通过，如果用<code>select</code> + <code>delete</code>来校验<code>token</code>，存在并发问题，不建议使用</p>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>  获取数据的时候加锁获取 </p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">select * from table_xxx where id&#x3D;&#39;xxx&#39; for update; <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  <strong>注意：</strong> <code>id</code>字段一定是主键或者唯一索引，不然是锁表，会死人的 </p>\n<p>  悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用  </p>\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>  乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 </p>\n<p>  乐观锁的实现方式多种多样可以通过<code>version</code>或者<code>其他状态</code>条件： </p>\n<ol>\n<li><p>通过版本号实现 </p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where version&#x3D;#version# <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>通过条件限制 </p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">update table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where avai_amount-#subAmount# &gt;&#x3D; 0 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<p>  <strong>要求：</strong> <code>quality-#subQuality# &gt;=</code> ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高  </p>\n<p>  <strong>注意：</strong> 乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好 </p>\n  <pre class=\"line-numbers language-none\"><code class=\"language-none\">update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where id&#x3D;#id# and version&#x3D;#version# \nupdate table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where id&#x3D;#id# and avai_amount-#subAmount# &gt;&#x3D; 0  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><p>  还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，</p>\n<p>  这时候可以引入分布式锁，通过第三方的系统(<code>redis</code>或<code>zookeeper</code>)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，</p>\n<p>  这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 </p>\n<p>  <strong>要点：</strong>某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(<code>用户ID</code>+<code>后缀</code>等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)</p>\n<h3 id=\"select-insert\"><a href=\"#select-insert\" class=\"headerlink\" title=\"select + insert\"></a>select + insert</h3><p>  并发不高的后台系统，或者一些任务<code>JOB</code>，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了  </p>\n<p>  <strong>注意：</strong> 核心高并发流程不要用这种方法  </p>\n<h3 id=\"对外提供接口的api如何保证幂等\"><a href=\"#对外提供接口的api如何保证幂等\" class=\"headerlink\" title=\"对外提供接口的api如何保证幂等\"></a>对外提供接口的api如何保证幂等</h3><p>  如银联提供的付款接口：需要接入商户提交付款请求时附带：<code>source</code>来源，<code>seq</code>序列号 </p>\n<p>  <code>source</code> + <code>seq</code> 在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求) </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>重点：</strong><br>对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，<br>这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；<br>没有处理过，进行相应处理，返回结果。<br>注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。  </p></blockquote>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li><p>幂等与你是不是分布式高并发没有关系。关键是你的操作是不是幂等的。</p>\n<ul>\n<li>一个幂等的操作典型如：把编号为<code>5</code>的记录的<code>A字段</code>设置为<code>0</code>这种操作不管执行多少次都是幂等的。</li>\n<li>一个非幂等的操作典型如：把编号为<code>5</code>的记录的<code>A字段</code>增加<code>1</code>这种操作显然就不是幂等的。</li>\n</ul>\n</li>\n<li><p>要做到幂等性，从接口设计上来说不设计任何非幂等的操作即可。</p>\n</li>\n<li><p>譬如说需求是：当用户点击赞同时，将答案的赞同数量<code>+1</code>。改为：当用户点击赞同时，确保答案赞同表中存在一条记录，用户、答案。赞同数量由答案赞同表统计出来。</p>\n</li>\n<li><p>总之幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是<code>钱</code>的系统，</p>\n</li>\n</ul>\n<hr>\n","text":"http请求的类型： get 获取商品信息， 这个会引起商品的数据的变化吗？ post 比较常见，这种接口需要考虑到幂等性 put 没有幂等的问题的情况：把1号商品的价格改为200，网络返回的时候抖动了，重试 ,第二次接口还是会把1号商品的价格改为200 出现幂等性问题的情况： ...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"Micro","slug":"Micro","count":3,"path":"api/categories/Micro.json"}],"tags":[{"name":"微服务","slug":"微服务","count":1,"path":"api/tags/微服务.json"},{"name":"幂等性机制","slug":"幂等性机制","count":1,"path":"api/tags/幂等性机制.json"},{"name":"幂等性解决方案","slug":"幂等性解决方案","count":1,"path":"api/tags/幂等性解决方案.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#http%E8%AF%B7%E6%B1%82%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">http请求的类型：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B6%85%E6%97%B6-%E9%87%8D%E8%AF%95-%E5%B9%82%E7%AD%89%E6%80%A7%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">超时 重试 幂等性机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B6%85%E6%97%B6\"><span class=\"toc-text\">超时</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%AF%95\"><span class=\"toc-text\">重试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%82%E7%AD%89\"><span class=\"toc-text\">幂等</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">常见的幂等性解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%96%B0%E5%A2%9E%E8%84%8F%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">数据库唯一索引，防止新增脏数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#token%E6%9C%BA%E5%88%B6%EF%BC%8C%E9%98%B2%E6%AD%A2%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">token机制，防止页面重复提交</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">悲观锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81\"><span class=\"toc-text\">乐观锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">分布式锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#select-insert\"><span class=\"toc-text\">select + insert</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E7%9A%84api%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89\"><span class=\"toc-text\">对外提供接口的api如何保证幂等</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol>","author":{"name":"G","slug":"blog-author","avatar":"https://froggyfriends.mypinata.cloud/ipfs/QmaTJi8B2cH5QKiXz1XneEuDaL1WC71uuq2A1X9t4sfacT","link":"/","description":"一位正在重塑知识的技术人 <br />","socials":{"github":"https://github.com/gzwillyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/svg/telegram.svg","link":"https://t.me/gzwilly"}}}},"mapped":true,"prev_post":{"title":"微服务 之 服务雪崩","uid":"04abdce79ce1414cc92810e537b53ae4","slug":"micro-avalanche","date":"2023-01-12T06:45:02.000Z","updated":"2023-01-12T06:45:02.000Z","comments":true,"path":"api/articles/micro-avalanche.json","keywords":null,"cover":"https://images.unsplash.com/photo-1667372459567-3853510dd5ce","text":"服务雪崩现象从服务雪崩开始讲起！假设存在如下调用链 : Service A -&gt; Service B -&gt; Service C 此时，Service A的流量波动很大，流量经常会突然性增加！ 那么在这种情况下，就算Service A能扛得住请求，Service B和S...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Micro","slug":"Micro","count":3,"path":"api/categories/Micro.json"}],"tags":[{"name":"服务雪崩","slug":"服务雪崩","count":1,"path":"api/tags/服务雪崩.json"}],"author":{"name":"G","slug":"blog-author","avatar":"https://froggyfriends.mypinata.cloud/ipfs/QmaTJi8B2cH5QKiXz1XneEuDaL1WC71uuq2A1X9t4sfacT","link":"/","description":"一位正在重塑知识的技术人 <br />","socials":{"github":"https://github.com/gzwillyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/svg/telegram.svg","link":"https://t.me/gzwilly"}}}},"feature":true},"next_post":{"title":"CentOS8 安装 Docker Engine(Docker CE) 及 Docker Compose","uid":"8dfd1c27e715ba69975506c84ee456c0","slug":"centos8-install-docker","date":"2023-01-11T04:10:02.000Z","updated":"2023-01-11T04:10:02.000Z","comments":true,"path":"api/articles/centos8-install-docker.json","keywords":null,"cover":"https://images.unsplash.com/photo-1646627927863-19874c27316b","text":" 相关文档 Docker 官方文档 Docker Compose 版本发布页 添加存储库dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo 安装Docker包d...","link":"","photos":[],"count_time":{"symbolsCount":896,"symbolsTime":"1 mins."},"categories":[{"name":"Notes","slug":"Notes","count":3,"path":"api/categories/Notes.json"}],"tags":[{"name":"Centos8","slug":"Centos8","count":3,"path":"api/tags/Centos8.json"},{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"},{"name":"Docker Compose","slug":"Docker-Compose","count":1,"path":"api/tags/Docker-Compose.json"}],"author":{"name":"G","slug":"blog-author","avatar":"https://froggyfriends.mypinata.cloud/ipfs/QmaTJi8B2cH5QKiXz1XneEuDaL1WC71uuq2A1X9t4sfacT","link":"/","description":"一位正在重塑知识的技术人 <br />","socials":{"github":"https://github.com/gzwillyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/svg/telegram.svg","link":"https://t.me/gzwilly"}}}}}}
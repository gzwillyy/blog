{"title":"Go语言 之 项目设计(汇总)","uid":"fabd4c31ac9eef22c08bf05f6fc86b54","slug":"go-project-design-lint","date":"2023-02-03T03:05:50.000Z","updated":"2023-02-03T03:05:50.000Z","comments":true,"path":"api/articles/go-project-design-lint.json","keywords":null,"cover":"https://i.328888.xyz/2023/02/03/IKcpL.jpeg","content":"<ul>\n<li>本文摘自<a href=\"https://juejin.cn/book/7176608782871429175\">《从零开发企业级 Go 应用》</a></li>\n</ul>\n<p>如何构建出一个完整的 Go 项目，并且尽可能地说明开发过程中我的思考。希望能够通过这些思考让你知道如何开发 Go 项目，并且了解其他开发者的开发思路。</p>\n<h2 id=\"项目研发流程介绍\"><a href=\"#项目研发流程介绍\" class=\"headerlink\" title=\"项目研发流程介绍\"></a>项目研发流程介绍</h2><p>在动手撸代码之前，你最好先鸟瞰整个 Go 项目开发流程，通过对流程的了解，可以减少你在初次进行完整 Go 项目开发中的那种“不知所措”的感觉，可以让你掌握业界最优、也是最标准的项目开发流程，增强你的自信。</p>\n<p>业界通常把研发流程分为六个阶段，分别是需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段。其中，开发人员需要参与的阶段有 4 个：设计阶段、开发阶段、测试阶段和发布阶段。研发流程及流程中每个阶段的具体内容，如下图所示：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d1c206d83f642feb5877279343c8832~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\">  </p>\n<p>作为一名开发人员，在设计阶段也会有一些设计类工作需要你去完成，例如：规范设计、目录结构设计、工作流设计、研发流程设计、Go 代码结构设计等，其中比较重要的设计是规范设计、目录结构设计、Go 代码结构设计。接下来，我会详细介绍如何来设计这些内容。</p>\n<h2 id=\"规范设计\"><a href=\"#规范设计\" class=\"headerlink\" title=\"规范设计\"></a>规范设计</h2><p>规范设计内容也比较多，通常包含代码规范、Commit 规范、版本规范、接口规范、日志规范、错误码规范等。</p>\n<ul>\n<li><p><strong>代码规范：</strong> <a href=\"./go-code-lint\">Go 代码开发规范</a>。</p>\n</li>\n<li><p><strong>Commit 规范：</strong> <a href=\"./go-commit-lint\">Commit 规范</a>。</p>\n</li>\n<li><p><strong>版本规范：</strong> <a href=\"./go-version-lint\">版本规范</a>。</p>\n</li>\n<li><p><strong>接口规范：</strong> <a href=\"./go-api-lint\">接口规范</a>。</p>\n</li>\n<li><p><strong>日志规范：</strong> <a href=\"./go-logging-lint\">接口规范</a>。</p>\n</li>\n<li><p><strong>错误码规范：</strong> <a href=\"./go-errorcode-lint\">错误码规范：</a>。</p>\n</li>\n</ul>\n<p>上面只列举了一些常用的规范，对于一个项目来说，如果有需要可以制定更多的规范，例如：开发流程规范、发布规范、校验规范等。这些规范不仅可以提高代码质量，还可以提高研发效率，降低后期的代码维护成本和学习成本。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>提示：在实际开发中，大部分团队和项目其实也只用到了这些规范。甚至，我所见过的更多的团队，包括腾讯、阿里内部的不少团队都没有制定过开发规范，或者说一些团队只是在项目开始时曾经制定过规范，但随着项目的迭代，会遗忘这些规范。</p></blockquote>\n<p>规范是开发人员制定的软约束，靠开发人员自觉的去遵守，并不太可行。在实际开发中，我们要多思考怎么通过工具去保证这些规范被遵守，例如：可以通过 <code>golangci-lint</code> 进行静态代码检查，来保证代码规范；通过 <code>gitlint</code> 工具来保证 Commit 规范；通过 <code>gsemver</code> 工具来生 SemVer 格式的版本号；通过 OpenAPI 编辑器来编写 OpenAPI 接口文档；通过调用统一的请求返回方法，来确保错误码规范；通过开发规范化的日志包，来保证日志规范等。</p>\n<h2 id=\"目录结构设计\"><a href=\"#目录结构设计\" class=\"headerlink\" title=\"目录结构设计\"></a>目录结构设计</h2><p>目录结构是一个项目的门面。很多时候，根据目录结构就能看出开发者对这门语言的掌握程度。所以，在我看来，遵循一个好的目录规范，把代码目录设计的可维护、可扩展，甚至比文档规范、Commit 规范都要重要。通常，根据功能，可以将目录结构分为以下两种。</p>\n<ul>\n<li><p><strong>平铺式目录结构：</strong> 主要用在 Go 包中，相对简单。</p>\n</li>\n<li><p><strong>结构化目录结构：</strong> 主要用在 Go 应用中，相对复杂。</p>\n</li>\n</ul>\n<h3 id=\"平铺式目录结构\"><a href=\"#平铺式目录结构\" class=\"headerlink\" title=\"平铺式目录结构\"></a>平铺式目录结构</h3><p>一个 Go 项目可以是一个应用，也可以是一个代码库，当项目是代码库时，比较适合采用平铺式目录结构。</p>\n<p>平铺方式就是在项目的根目录下存放项目的代码，整个目录结构看起来更像是一层的，这种方式在很多库中存在，使用这种方式的好处是引用路径长度明显减少。例如 <a href=\"https://github.com/golang/glog\">glog</a> 包就是平铺式的，目录内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ ls glog&#x2F;\nglog_file.go  glog.go  glog_test.go  go.mod  LICENSE  README.md<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>对于一些功能简单的工具或项目，也可以采用平铺式的目录结构，以减小开发者的理解成本和编写复杂度。</p>\n<h3 id=\"结构化目录结构\"><a href=\"#结构化目录结构\" class=\"headerlink\" title=\"结构化目录结构\"></a>结构化目录结构</h3><p>当前 Go 社区比较推荐的结构化目录结构是 <a href=\"https://link.juejin.cn/?target=https://github.com/golang-standards/project-layout\" title=\"https://github.com/golang-standards/project-layout\">project-layout</a>。虽然它并不是官方和社区的规范，但因为组织方式比较合理，被很多 Go 开发人员接受。所以，我们可以把它当作是一个事实上的规范。本实战项目 miniblog 目录也遵循了 project-layout 项目的目录规范。</p>\n<h3 id=\"miniblog-目录结构设计\"><a href=\"#miniblog-目录结构设计\" class=\"headerlink\" title=\"miniblog 目录结构设计\"></a>miniblog 目录结构设计</h3><ul>\n<li><a href=\"https://github.com/marmotedu/miniblog\"> https://github.com/marmotedu/miniblog</a></li>\n</ul>\n<p>miniblog 目录结构遵循了 project-layout 的目录结构设计。项目目录及功能介绍如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">├── api # Swagger &#x2F; OpenAPI 文档存放目录\n│   └── openapi\n│       └── openapi.yaml # OpenAPI 3.0 API 接口文档\n├── cmd # main 文件存放目录\n│   └── miniblog\n│       └── miniblog.go\n├── configs # 配置文件存放目录\n│   ├── miniblog.sql # 数据库初始化 SQL\n│   ├── miniblog.yaml # miniblog 配置文件\n│   └── nginx.conf # Nginx 配置\n├── docs # 项目文档\n│   ├── devel # 开发文档\n│   │   ├── en-US # 英文文档\n│   │   └── zh-CN # 中文文档\n│   │       ├── architecture.md # miniblog 架构介绍\n│   │       ├── conversions # 规范文档存放目录\n│   │       │   ├── api.md # 接口规范\n│   │       │   ├── commit.md # Commit 规范\n│   │       │   ├── directory.md # 目录结构规范\n│   │       │   ├── error_code.md # 错误码规范\n│   │       │   ├── go_code.md # 代码规范\n│   │       │   ├── log.md # 日志规范\n│   │       │   └── version.md # 版本规范\n│   │       └── README.md\n│   ├── guide # 用户文档\n│   │   ├── en-US # 英文文档\n│   │   └── zh-CN # 中文文档\n│   │       ├── announcements.md # 动态与公告\n│   │       ├── best-practice # 最佳实践\n│   │       ├── faq # 常见问题\n│   │       ├── installation # 安装指南\n│   │       ├── introduction # 产品介绍\n│   │       ├── operation-guide # 操作指南\n│   │       ├── quickstart # 快速入门\n│   │       └── README.md\n│   └── images # 项目图片存放目录\n├── examples # 示例源码\n├── go.mod\n├── go.sum\n├── init # Systemd Unit 文件保存目录\n│   ├── miniblog.service # miniblog systemd unit\n├── internal # 内部代码保存目录，这里面的代码不能被外部程序引用\n│   ├── miniblog # miniblog 代码实现目录\n│   │   ├── biz # biz 层代码\n│   │   ├── controller # controller 层代码\n│   │   │   └── v1 # API 接口版本\n│   │   │       ├── post # 博客相关代码实现\n│   │   │       │   ├── create.go # 创建博客\n│   │   │       │   ├── delete_collection.go #批量删除博客\n│   │   │       │   ├── delete.go # 删除博客\n│   │   │       │   ├── get.go # 获取博客详情\n│   │   │       │   ├── list.go # 获取博客列表\n│   │   │       │   ├── post.go # 博客 Controller 结构定义、创建\n│   │   │       │   └── update.go # 更新博客\n│   │   │       └── user\n│   │   │           ├── change_password.go # 修改用户密码\n│   │   │           ├── create.go #创建用户\n│   │   │           ├── delete.go # 删除用户\n│   │   │           ├── get.go # 获取用户详情\n│   │   │           ├── list.go # 获取用户列表\n│   │   │           ├── login.go # 用户登录\n│   │   │           ├── update.go  # 更新用户\n│   │   │           └── user.go # 用户 Controller 结构定义、创建\n│   │   ├── helper.go # 工具类代码存放文件\n│   │   ├── miniblog.go # miniblog 主业务逻辑实现代码\n│   │   ├── router.go # Gin 路由加载代码\n│   │   └── store # store 层代码\n│   └── pkg # 内部包保存目录\n│       ├── core # core 包，用来保存一些核心的函数\n│       ├── errno # errno 包，实现了 miniblog 的错误码功能\n│       │   ├── code.go # 错误码定义文件\n│       │   └── errno.go # errno 包功能函数文件\n│       ├── known # 存放项目级的常量定义\n│       ├── log # miniblog 自定义 log 包\n│       ├── middleware # Gin 中间件包\n│       │   ├── authn.go # 认证中间件\n│       │   ├── authz.go # 授权中间件\n│       │   ├── header.go # 指定 HTTP Response Header\n│       │   └── requestid.go # 请求 &#x2F; 返回头中添加 X-Request-ID\n│       └── model # GORM Model\n├── LICENSE # 声明代码所遵循的开源协议\n├── Makefile # Makefile 文件，一般大型软件系统都是采用 make 来作为编译工具\n├── _output # 临时文件存放目录\n├── pkg # 可供外部程序直接使用的 Go 包存放目录\n│   ├── api # REST API 接口定义存放目录\n│   ├── proto # Protobuf 接口定义存放目录\n│   ├── auth # auth 包，用来完成认证、授权功能\n│   │   ├── authn.go # 认证功能\n│   │   └── authz.go # 授权功能\n│   ├── db # db 包，用来完成 MySQL 数据库连接\n│   ├── token # JWT Token 的签发和解析\n│   ├── util # 工具类包存放目录\n│   │   └── id # id 包，用来生成唯一短 ID\n│   └── version # version 包，用来保存 &#x2F; 输出版本信息\n├── README-en.md # 英文 README\n├── README.md # 中文 README\n├── scripts # 脚本文件\n│   ├── boilerplate.txt # 指定版权头信息\n│   ├── coverage.awk # awk 脚本，用来计算覆盖率\n│   ├── make-rules # 子 Makefile 保存目录\n│   │   ├── common.mk # 存放通用的 Makefile 变量\n│   │   ├── golang.mk # 用来编译源码\n│   │   └── tools.mk # 用来完成工具的安装\n│   └── wrktest.sh # wrk 性能测试脚本\n└── third_party # 第三方 Go 包存放目录<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>跟 project-layout 目录规范唯一不一样的地方是，miniblog 将具体的实现目录 miniblog 放在 <code>internal/</code> 目录下，而非 <code>internal/app/</code> 目录下，例如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ ls internal&#x2F;         \nminiblog  pkg<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这样做既可以保证 <code>internal</code> 目录下的文件功能清晰、整齐，又能缩短引用路径。</p>\n<h2 id=\"代码结构设计\"><a href=\"#代码结构设计\" class=\"headerlink\" title=\"代码结构设计\"></a>代码结构设计</h2><p>项目代码设计遵循简洁架构设计，一个简洁架构具有以下 5 个特性：</p>\n<ul>\n<li><p><strong>独立于框架：</strong> 该架构不会依赖于某些功能强大的软件库存在。这可以让你使用这样的框架作为工具，而不是让你的系统陷入到框架的约束中。</p>\n</li>\n<li><p><strong>可测试性：</strong> 业务规则可以在没有 UI、数据库、Web 服务或其他外部元素的情况下进行测试，在实际的开发中，我们通过 Mock 来解耦这些依赖。</p>\n</li>\n<li><p><strong>独立于UI ：</strong> 在无需改变系统其他部分的情况下，UI 可以轻松地改变。例如，在没有改变业务规则的情况下，Web UI 可以替换为控制台 UI。</p>\n</li>\n<li><p><strong>独立于数据库：</strong> 你可以用 Mongo、Oracle、Etcd 或者其他数据库来替换 MariaDB，你的业务规则不要绑定到数据库。</p>\n</li>\n<li><p><strong>独立于外部媒介：</strong> 实际上，你的业务规则可以简单到根本不去了解外部世界。</p>\n</li>\n</ul>\n<p><strong>所以，基于这些约束，每一层都必须是独立的和可测试的。代码架构分为 4 层：模型层（Model）、控制层（Controller）、业务层 （Biz）、仓库层（Store）。从控制层、业务层到仓库层，从左到右层级依次加深。模型层独立于其他层，可供其他层引用。代码架构如下图所示：</strong></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2da85aa1405945519dbf5f645587fb5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\"></p>\n<p><strong>层与层之间导入包时，都有严格的导入关系，这可以防止包的循环导入问题。导入关系如下：</strong></p>\n<ul>\n<li>模型层的包可以被仓库层、业务层和控制层导入。</li>\n<li>控制层能够导入业务层和仓库层的包。这里需要注意，如果没有特殊需求，控制层要避免导入仓库层的包，控制层需要完成的业务功能都通过业务层来完成。</li>\n<li>业务层能够导入仓库层的包。</li>\n</ul>\n<h3 id=\"四层架构\"><a href=\"#四层架构\" class=\"headerlink\" title=\"四层架构\"></a>四层架构</h3><p><strong>接下来，我们就来详细看下每一层所完成的功能，以及其中的一些注意点：</strong></p>\n<ol>\n<li>模型层（Model）：模型层在有些软件架构中也叫做实体层（Entities），模型会在每一层中使用，在这一层中存储对象的结构和它的方法。</li>\n<li>控制层（Controller）：控制层接收 HTTP 请求，并进行参数解析、参数校验、逻辑分发处理、请求返回这些操作。控制层会将逻辑分发给业务层，业务层处理后返回，返回数据在控制层中被整合再加工，最终返回给请求方。控制层相当于实现了业务路由的功能。具体流程如下图所示：</li>\n<li>业务层 (Biz)：业务层主要用来完成业务逻辑处理，我们可以把所有的业务逻辑处理代码放在业务层。业务层会处理来自控制层的请求，并根据需要请求仓库层完成数据的 CURD 操作。业务层功能如下图所示：</li>\n<li>仓库层（Store)：仓库层用来跟数据库&#x2F;第三方服务进行 CURD 交互，作为应用程序的数据引擎进行应用数据的输入和输出。这里需要注意，仓库层仅对数据库&#x2F;第三方服务执行 CRUD 操作，不封装任何业务逻辑。这一层也会起到数据转换的作用：将从数据库&#x2F;微服务中获取的数据转换为控制层、业务层能识别的数据结构，将控制层、业务层的数据格式转换为数据库或微服务能识别的数据格式。</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf1b54fea8bd4e2e9a059b4b10599787~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\"><br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89451e92ff3f4f888e56f16c638bbc55~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\"></p>\n<h3 id=\"层之间的通信\"><a href=\"#层之间的通信\" class=\"headerlink\" title=\"层之间的通信\"></a>层之间的通信</h3><p>上面介绍了 4 层结构，接下来我们再看看每一层之间是如何通信的。</p>\n<p>除了模型层，控制层、业务层、仓库层之间都是通过接口进行通信的。通过接口通信，一方面可以使相同的功能支持不同的实现（也就是说具有插件化能力），另一方面也使得每一层的代码变得可测试。</p>\n<h3 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h3><p>控制层、业务层和仓库层之间是通过接口来通信的。通过接口通信有一个好处，就是可以让各层变得可测。那接下来，我们就来看下如何测试各层的代码。这里只介绍下测试思路。</p>\n<ol>\n<li>模型层: 因为模型层不依赖其他任何层，我们只需要测试其中定义的结构及其函数和方法即可。</li>\n<li>控制层: 控制层依赖于业务层，意味着该层需要业务层来支持测试。你可以通过 <code>golang/mock</code> 来 mock 业务层</li>\n<li>业务层: 因为该层依赖于仓库层，意味着该层需要仓库层来支持测试。你可以通过 <code>golang/mock</code> 来 mock 仓库层</li>\n<li>仓库层: 仓库层依赖于数据库，如果调用了其他微服务，那还会依赖第三方服务。我们可以通过 <a href=\"https://github.com/DATA-DOG/go-sqlmock\">sqlmock</a> 来模拟数据库连接，通过 <a href=\"https://github.com/jarcoal/httpmock\">httpmock</a> 来模拟 HTTP 请求。</li>\n</ol>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>比较重要的工作有：规范设计、目录结构设计和代码结构设计。其中规范类，本课程采用了业界的最佳规范实践，目录结构采用了当前最受 Go 开发者欢迎的 <code>project-layout</code> 目录结构，代码结构采用了简洁架构。</p>\n","feature":true,"text":" 本文摘自《从零开发企业级 Go 应用》 如何构建出一个完整的 Go 项目，并且尽可能地说明开发过程中我的思考。希望能够通过这些思考让你知道如何开发 Go 项目，并且了解其他开发者的开发思路。 项目研发流程介绍在动手撸代码之前，你最好先鸟瞰整个 Go 项目开发流程，通过对流程的了...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"Golang","slug":"Golang","count":8,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":8,"path":"api/tags/Golang.json"},{"name":"项目设计","slug":"项目设计","count":1,"path":"api/tags/项目设计.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B9%E7%9B%AE%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">项目研发流程介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%84%E8%8C%83%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">规范设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">目录结构设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E9%93%BA%E5%BC%8F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">平铺式目录结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">结构化目录结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#miniblog-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">miniblog 目录结构设计</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">代码结构设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">四层架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">层之间的通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">代码测试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol>","author":{"name":"G","slug":"blog-author","avatar":"https://froggyfriends.mypinata.cloud/ipfs/QmaTJi8B2cH5QKiXz1XneEuDaL1WC71uuq2A1X9t4sfacT","link":"/","description":"一位正在重塑知识的技术人 <br />","socials":{"github":"https://github.com/gzwillyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/svg/telegram.svg","link":"https://t.me/gzwilly"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Go语言项目开发规范 之 Commit规范","uid":"a5920cb23f39d78f08d5111f3bca2f52","slug":"go-commit-lint","date":"2023-02-02T12:50:39.000Z","updated":"2023-02-02T12:50:39.000Z","comments":true,"path":"api/articles/go-commit-lint.json","keywords":null,"cover":"https://i.328888.xyz/2023/02/03/IKcpL.jpeg","text":"Commit 规范 本文摘自《从零开发企业级 Go 应用》 Conventional Commits 规范。 中文翻译版：Conventional Commits：一份让代码提交记录人机友好的规范 ","link":"","photos":[],"count_time":{"symbolsCount":109,"symbolsTime":"1 mins."},"categories":[{"name":"Golang","slug":"Golang","count":8,"path":"api/categories/Golang.json"}],"tags":[{"name":"开发规范","slug":"开发规范","count":7,"path":"api/tags/开发规范.json"},{"name":"Golang","slug":"Golang","count":8,"path":"api/tags/Golang.json"},{"name":"Commit规范","slug":"Commit规范","count":1,"path":"api/tags/Commit规范.json"}],"author":{"name":"G","slug":"blog-author","avatar":"https://froggyfriends.mypinata.cloud/ipfs/QmaTJi8B2cH5QKiXz1XneEuDaL1WC71uuq2A1X9t4sfacT","link":"/","description":"一位正在重塑知识的技术人 <br />","socials":{"github":"https://github.com/gzwillyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/svg/telegram.svg","link":"https://t.me/gzwilly"}}}},"feature":true}}
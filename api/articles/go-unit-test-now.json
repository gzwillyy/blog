{"title":"Go语言 之 单元测试","uid":"61e8b2592f9fa7223d28fd1483d57107","slug":"go-unit-test-now","date":"2023-02-14T00:33:57.000Z","updated":"2023-02-14T00:33:57.000Z","comments":true,"path":"api/articles/go-unit-test-now.json","keywords":null,"cover":"https://i.328888.xyz/2023/02/03/IKcpL.jpeg","content":"<ul>\n<li>本文摘自<a href=\"https://juejin.cn/book/7176608782871429175\">《从零开发企业级 Go 应用》</a></li>\n</ul>\n<p>在实际开发中，不仅要开发功能，更重要的是确保这些功能稳定可靠，并且拥有一个不错的性能，要确保这些，就要对代码进行测试。测试分为很多种，例如：功能测试、性能测试、集成测试、端到端测试、单元测试等。</p>\n<p>对于开发者，需要执行的测试种类一般是单元测试和性能测试。除此之外，Go 还提供了其他类型的测试，例如：模糊测试、示例测试。本节课，我就来详细介绍下开发者可以执行的测试种类，以及如何编写和执行测试用例。</p>\n<p>这里，想跟大家分享下，在实际项目开发中，开发人员编写并执行单元测试的现状。</p>\n<p>其实，即使在像腾讯、阿里这样的大厂，也并没有多少开发人员能够在开发过程中，编写高质量、高覆盖率的单元测试用例。并不是说编写单元测试用例不重要，而是，在项目开发过程中，你可能经常需要忙于追赶项目进度，而没时间去编写单元测试用例。</p>\n<p>在实际开发中，<strong>开发者一般不太习惯随时编写单元测试用例，并不是说编写单元测试用例不重要</strong>，而是因为很多时候，实现功能需求优先级更高。这里分享下我对编写单元测试用例的一点思考：</p>\n<ul>\n<li><p>编写单元测试用例很重要，但单元测试用例并不一定需要边开发边编写。很多时候，我们需要在功能开发进度和编写单元测试用例之间进行权衡；</p>\n</li>\n<li><p>对于开发过程中，需要编写代码测试某块功能的时候，不妨顺便将测试代码变成单元测试用例；</p>\n</li>\n<li><p>单元测试用例对后期的代码维护很重要，在项目上线后，如果有时间，建议补全单元测试用例。</p>\n</li>\n</ul>\n<h2 id=\"Go-语言如何编写测试用例？\"><a href=\"#Go-语言如何编写测试用例？\" class=\"headerlink\" title=\"Go 语言如何编写测试用例？\"></a>Go 语言如何编写测试用例？</h2><p>Go 语言有自带的测试框架 <code>testing</code>，可以用来实现单元测试和性能测试，通过 <code>go test</code> 命令来执行单元测试和性能测试。</p>\n<p><code>go test</code> 执行测试用例时，是以 Go 包为单位进行测试的。执行时需要指定包名，比如：<code>go test 包名</code>，如果没有指定包名，默认会选择执行命令时所在的包。<code>go test</code> 在执行时会遍历以 <code>_test.go</code> 结尾的源码文件，执行其中以 <code>Test</code>、<code>Benchmark</code>、<code>Example</code>、<code>Fuzz</code> 开头的测试函数。其中源码文件需要满足以下规范：</p>\n<ul>\n<li>文件名必须是 <code>_test.go</code> 结尾，跟源文件在同一个包；</li>\n<li>测试用例函数必须以 <code>Test</code>、<code>Benchmark</code>、<code>Example</code>、<code>Fuzz</code> 开头；</li>\n<li>执行测试用例时的顺序，会按照源码中的顺序依次执行；</li>\n<li>单元测试函数 <code>TestXxx()</code> 的参数是 <code>testing.T</code>，可以使用该类型来记录错误或测试状态；</li>\n<li>性能测试函数 <code>BenchmarkXxx()</code> 的参数是 <code>testing.B</code>，函数内以 <code>b.N</code> 作为循环次数，其中 <code>N</code> 会动态变化；</li>\n<li>示例函数 <code>ExampleXxx()</code> 没有参数，执行完会将输出与注释 <code>// Output:</code> 进行对比；</li>\n<li>测试函数原型：<code>func TestXxx(t *testing.T)</code>，<code>Xxx</code> 部分为任意字母数字组合，首字母大写，例如： <code>TestgenShortId</code> 是错误的函数名，<code>TestGenShortId</code> 是正确的函数名；</li>\n<li>通过调用 <code>testing.T</code> 的 <code>Error</code>、<code>Errorf</code>、<code>FailNow</code>、<code>Fatal</code>、<code>FatalIf</code> 方法来说明测试不通过，通过调用 <code>Log</code>、<code>Logf</code> 方法来记录测试信息：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">t.Log t.Logf     # 正常信息 \nt.Error t.Errorf # 测试失败信息 \nt.Fatal t.Fatalf # 致命错误，测试程序退出的信息\nt.Fail     # 当前测试标记为失败\nt.Failed   # 查看失败标记\nt.FailNow  # 标记失败，并终止当前测试函数的执行，需要注意的是，我们只能在运行测试函数的 Goroutine 中调用 t.FailNow 方法，而不能在我们在测试代码创建出的 Goroutine 中调用它\nt.Skip     # 调用 t.Skip 方法相当于先后对 t.Log 和 t.SkipNow 方法进行调用，而调用 t.Skipf 方法则相当于先后对 t.Logf 和 t.SkipNow 方法进行调用。方法 t.Skipped 的结果值会告知我们当前的测试是否已被忽略\nt.Parallel # 标记为可并行运算<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Go-语言测试种类及用例编写方法\"><a href=\"#Go-语言测试种类及用例编写方法\" class=\"headerlink\" title=\"Go 语言测试种类及用例编写方法\"></a>Go 语言测试种类及用例编写方法</h2><p>上面，我介绍了 Go 语言层面对测试用例的支持，这里我就简单介绍下常见的测试用例编写及执行方法。</p>\n<p>在实际项目开发中，我们编写最多的是单元测试用例，接着是性能测试用例，在某些场景还可能会需要编写模糊测试用例。</p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>在 <code>pkg/util/id/</code> 目录下创建文件 <code>id_test.go</code>，内容为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package id\n\nimport (\n    &quot;testing&quot;\n\n    &quot;github.com&#x2F;stretchr&#x2F;testify&#x2F;assert&quot;\n)\n\nfunc TestGenShortID(t *testing.T) &#123;\n    shortID :&#x3D; GenShortID()\n    assert.NotEqual(t, &quot;&quot;, shortID)\n    assert.Equal(t, 6, len(shortID))\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>你可以通过运行 <code>go test</code> 命令来执行测试用例。<code>go test</code> 通过不同的参数，来支持不同的测试效果，常用的 <code>go test</code> 命令如下：</p>\n<ul>\n<li><strong>执行默认的测试用例</strong></li>\n</ul>\n<p>在 <code>pkg/util/id/</code> 目录下执行命令 <code>go test</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>根据 <code>go test</code> 的输出可以知道 <code>TestGenShortID</code> 用例测试通过。</p>\n<ul>\n<li><strong>查看更详细的执行信息</strong></li>\n</ul>\n<p>要查看更详细的执行信息可以执行 <code>go test -v</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test -v\n&#x3D;&#x3D;&#x3D; RUN   TestGenShortID\n--- PASS: TestGenShortID (0.00s)\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><strong>执行测试</strong> <strong><code>N</code></strong> <strong>次</strong></li>\n</ul>\n<p>如果要执行测试 <code>N</code> 次可以使用 <code>-count N</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test -v -count 2\n&#x3D;&#x3D;&#x3D; RUN   TestGenShortID\n--- PASS: TestGenShortID (0.00s)\n&#x3D;&#x3D;&#x3D; RUN   TestGenShortID\n--- PASS: TestGenShortID (0.00s)\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><strong>只运行指定的单测用例</strong></li>\n</ul>\n<p>此外，你还可以只运行指定的单测用例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test -run TestGenShortID -v\n&#x3D;&#x3D;&#x3D; RUN   TestGenShortID\n--- PASS: TestGenShortID (0.00s)\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>-run</code> 参数支持正则表达式。</p>\n<h3 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h3><p>在企业应用开发中，也需要你学会编写和运行性能测试用例。</p>\n<h4 id=\"编写性能测试用例\"><a href=\"#编写性能测试用例\" class=\"headerlink\" title=\"编写性能测试用例\"></a>编写性能测试用例</h4><p>在 <code>pkg/util/id/id_test.go</code> 测试文件中，新增两个性能测试函数：<code>BenchmarkGenShortID</code> 和 <code>BenchmarkGenShortIDTimeConsuming</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">func BenchmarkGenShortID(b *testing.B) &#123;\n    for i :&#x3D; 0; i &lt; b.N; i++ &#123;\n        GenShortID()\n    &#125;\n&#125;\n\nfunc BenchmarkGenShortIDTimeConsuming(b *testing.B) &#123;\n    b.StopTimer() &#x2F;&#x2F;调用该函数停止压力测试的时间计数\n\n    shortId :&#x3D; GenShortID()\n    if shortId &#x3D;&#x3D; &quot;&quot; &#123;\n        b.Error(&quot;Failed to generate short id&quot;)\n    &#125;\n\n    b.StartTimer() &#x2F;&#x2F;重新开始时间\n\n    for i :&#x3D; 0; i &lt; b.N; i++ &#123;\n        GenShortID()\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>代码说明：</strong></p>\n<ul>\n<li><p>性能测试函数名必须以 <code>Benchmark</code> 开头，如 <code>BenchmarkXxx</code> 或 <code>Benchmark_xxx</code>；</p>\n</li>\n<li><p><code>go test</code> 默认不会执行性能测试函数，需要通过指定参数 <code>-test.bench</code> 来运行性能测试函数，<code>-test.bench</code> 后跟正则表达式，如 <code>go test -test.bench=&quot;.*&quot;</code> 表示执行所有的性能测试函数；</p>\n</li>\n<li><p>在性能测试中，需要在循环体中指定 <code>testing.B.N</code> 来循环执行性能测试代码。</p>\n</li>\n</ul>\n<h4 id=\"运行性能测试用例\"><a href=\"#运行性能测试用例\" class=\"headerlink\" title=\"运行性能测试用例\"></a><strong>运行性能测试用例</strong></h4><p>在 <code>pkg/util/id/</code> 目录下执行命令 <code>go test -test.bench=&quot;.*&quot;</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test -test.bench&#x3D; &quot;.*&quot;\ngoos: linux\ngoarch: amd64\npkg: github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id\ncpu: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz\nBenchmarkGenShortID-16                           841854              1367 ns&#x2F;op\nBenchmarkGenShortIDTimeConsuming-16              880039              1349 ns&#x2F;op\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        2.376s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p>上面的结果显示，我们没有执行任何 <code>TestXXX</code> 的单元测试函数，只执行了性能测试函数；</p>\n</li>\n<li><p>第一条显示了 <code>BenchmarkGenShortID</code> 执行了 841854 次，每次的执行平均时间是 1367 纳秒；</p>\n</li>\n<li><p>第二条显示了 <code>BenchmarkGenShortIDTimeConsuming</code> 执行了 880039，每次的平均执行时间是 1349 纳秒；</p>\n</li>\n<li><p>最后一条显示总执行时间。</p>\n</li>\n</ul>\n<p><code>BenchmarkGenShortIdTimeConsuming</code> 比 <code>BenchmarkGenShortID</code> 多了两个调用 <code>b.StopTimer()</code> 和 <code>b.StartTimer()</code>：</p>\n<ul>\n<li><p><code>b.StopTimer()</code>：调用该函数停止性能测试的时间计数；</p>\n</li>\n<li><p><code>b.StartTimer()</code>：重新开始时间。</p>\n</li>\n</ul>\n<p>在 <code>b.StopTimer()</code> 和 <code>b.StartTimer()</code> 之间可以做一些准备工作，这样这些时间不影响我们测试函数本身的性能。</p>\n<h4 id=\"查看性能并生成函数调用图\"><a href=\"#查看性能并生成函数调用图\" class=\"headerlink\" title=\"查看性能并生成函数调用图\"></a>查看性能并生成函数调用图</h4><p>执行以下命令，保存性能测试指标：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test -bench&#x3D; &quot;.*&quot; -cpuprofile&#x3D;cpu.profile\ngoos: linux\ngoarch: amd64\npkg: github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id\ncpu: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz\nBenchmarkGenShortID-16                           909586              1319 ns&#x2F;op\nBenchmarkGenShortIDTimeConsuming-16              916029              1356 ns&#x2F;op\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        2.583s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上述命令会在当前目录下生成 <code>cpu.profile</code> 和 <code>id.test</code> 文件。</p>\n<p>之后，我们可以执行 <code>go tool pprof id.test cpu.profile</code> 查看性能（进入交互界面后执行 <code>top</code> 指令）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go tool pprof id.test cpu.profile\nFile: id.test\nType: cpu\nTime: Jan 11, 2023 at 4:18pm (CST)\nDuration: 2.58s, Total samples &#x3D; 2.54s (98.56%)\nEntering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)\n(pprof) top\nShowing nodes accounting for 2040ms, 80.31% of 2540ms total\nDropped 44 nodes (cum &lt;&#x3D; 12.70ms)\nShowing top 10 nodes out of 57\n      flat  flat%   sum%        cum   cum%\n    1490ms 58.66% 58.66%     1560ms 61.42%  syscall.Syscall\n     180ms  7.09% 65.75%      300ms 11.81%  runtime.mallocgc\n     110ms  4.33% 70.08%      110ms  4.33%  time.Now\n      60ms  2.36% 72.44%      140ms  5.51%  strings.ToLower\n      40ms  1.57% 74.02%     2250ms 88.58%  github.com&#x2F;jasonsoft&#x2F;go-short-id.Generate\n      40ms  1.57% 75.59%       40ms  1.57%  time.absDate\n      30ms  1.18% 76.77%     1630ms 64.17%  crypto&#x2F;rand.(*devReader).Read\n      30ms  1.18% 77.95%       30ms  1.18%  runtime.nextFreeFast (inline)\n      30ms  1.18% 79.13%       40ms  1.57%  runtime.reentersyscall\n      30ms  1.18% 80.31%       50ms  1.97%  runtime.scanobject\n(pprof) <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>pprof 程序中最重要的命令就是 <code>topN</code>，此命令用于显示 profile 文件中的最靠前的 <code>N</code> 个样本（sample），它的输出格式各字段的含义依次是：</p>\n<ol>\n<li><p>采样点落在该函数中的总时间；</p>\n</li>\n<li><p>采样点落在该函数中的百分比；</p>\n</li>\n<li><p>上一项的累积百分比；</p>\n</li>\n<li><p>采样点落在该函数，以及被它调用的函数中的总时间；</p>\n</li>\n<li><p>采样点落在该函数，以及被它调用的函数中的总次数百分比；</p>\n</li>\n<li><p>函数名。</p>\n</li>\n</ol>\n<p>此外，在 pprof 程序中还可以使用 <code>svg</code> 来生成函数调用关系图（需要安装 <code>graphviz</code>），例如：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d36c20ee79df4caa8496520c018e85e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\"></p>\n<p>该调用图生成方法如下：</p>\n<ol>\n<li>安装 <code>graphviz</code> 命令。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ sudo yum -y install graphviz.x86_64<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ol start=\"2\">\n<li>执行 <code>go tool pprof</code> 生成 svg 图。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go tool pprof id.test cpu.profile\nFile: id.test\nType: cpu\nTime: Jan 11, 2023 at 4:18pm (CST)\nDuration: 2.58s, Total samples &#x3D; 2.54s (98.56%)\nEntering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)\n(pprof) svg\nGenerating report in profile001.svg\n(pprof) <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>svg</code> 子命令会默认在当前目录下生成了一个 svg 文件 <code>profile001.svg</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>提示：</p>\n<ul>\n<li>关于如何看懂 pprof 信息，请参考官方文档 <a href=\"%22https://blog.golang.org/profiling-go-programs%22\">Profiling Go Programs</a>。</li>\n<li>关于如何做性能分析，请参考郝林大神的文章 <a href=\"%22https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md%22\">go tool pprof</a>。</li>\n</ul></blockquote>\n<h3 id=\"模糊测试\"><a href=\"#模糊测试\" class=\"headerlink\" title=\"模糊测试\"></a>模糊测试</h3><p>Fuzzing 是一种自动化的测试技术， 它不断地创建输入用来测试程序的 bug。 Go fuzzing 使用覆盖率智能指导遍历被模糊化测试的代码，发现缺陷并报告给用户。由于模糊测试可以达到人类经常忽略的边缘场景，因此它对于发现安全漏洞和缺陷特别有价值。</p>\n<p>Go 语言在 1.18 版本支持了模糊测试用例。</p>\n<p>单元测试有局限性，每个测试输入必须由开发者指定加到单元测试的测试用例里。Fuzzing 的优点之一是可以基于开发者代码里指定的测试输入作为基础数据，进一步自动生成新的随机测试数据，用来发现指定测试输入没有覆盖到的边界情况。</p>\n<p>然而 Fuzzing 也有一定的局限性， 在单元测试里，因为测试输入是固定的，你可以知道调用 <code>Reverse</code> 函数（Reverse 函数用来将传入的字符串进行翻转）后每个输入字符串得到的反转字符串应该是什么，然后在单元测试的代码里判断 <code>Reverse</code> 的执行结果是否和预期相符。但是使用 Fuzzing 时，我们没办法预期输出结果是什么。所以 Fuzzing 模糊测试和 Go 已有的单元测试以及性能测试框架是互为补充的，并不是替代关系。</p>\n<p>接下来就看一下如何编写模糊测试。</p>\n<p>在 <code>internal/miniblog/store</code> 目录下，新增 <code>helper_test.go</code> 文件，内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">package store\n\nimport (\n    &quot;testing&quot;\n\n    &quot;github.com&#x2F;stretchr&#x2F;testify&#x2F;assert&quot;\n)\n\n&#x2F;&#x2F; FuzzDefaultLimit 模糊测试用例.\nfunc FuzzDefaultLimit(f *testing.F) &#123;\n    testcases :&#x3D; []int&#123;0, 1, 2&#125;\n    for _, tc :&#x3D; range testcases &#123;\n        f.Add(tc)\n    &#125;\n\n    f.Fuzz(func(t *testing.T, orig int) &#123;\n        limit :&#x3D; defaultLimit(orig)\n        if orig &#x3D;&#x3D; 0 &#123;\n            assert.Equal(t, defaultLimitValue, limit)\n        &#125; else &#123;\n            assert.Equal(t, orig, limit)\n        &#125;\n    &#125;)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>FuzzDefaultLimit</code> 就是我们编写的模糊测试用例。</p>\n<p><strong>代码说明：</strong></p>\n<ul>\n<li><p>模糊测试用例函数名必须以 <code>Fuzz</code> 开头，例如：如 <code>FuzzXxx</code> 或 <code>Fuzz_xxx</code>。函数接收一个 <code>*testing.F</code> 类型的参数, 无返回值；</p>\n</li>\n<li><p><code>f.Add(tc)</code> 告诉了 Fuzzing 引擎我们需要的数据类型和顺序；</p>\n</li>\n<li><p><code>f.Fuzz</code> 函数传入一个用于模糊测试的函数，该函数的首个入参必须是 <code>*testing.T</code>，后面的参数就是你希望 Go 的 Fuzzing 引擎帮你生成的随机数据类型。并且要注意，这个函数不能有返回值。</p>\n</li>\n</ul>\n<p><strong>运行模糊测试用例：</strong></p>\n<p>我们可以通过以下 2 种方式来运行模糊测试用例。</p>\n<ul>\n<li>只使用种子语料库，而不生成随机测试数据。运行命令如下：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test -v -run&#x3D;FuzzDefaultLimit \n&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit\n&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit&#x2F;seed#0\n&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit&#x2F;seed#1\n&#x3D;&#x3D;&#x3D; RUN   FuzzDefaultLimit&#x2F;seed#2\n--- PASS: FuzzDefaultLimit (0.00s)\n    --- PASS: FuzzDefaultLimit&#x2F;seed#0 (0.00s)\n    --- PASS: FuzzDefaultLimit&#x2F;seed#1 (0.00s)\n    --- PASS: FuzzDefaultLimit&#x2F;seed#2 (0.00s)\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;internal&#x2F;miniblog&#x2F;store        0.020s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这个方式只会使用种子语料库，而不会生成随机测试数据。通过这种方式可以用来验证种子语料库的测试数据是否可以测试通过。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所谓语料库（seed corpus），就是一组用户提供的语料，Fuzzing 引擎将会使用这个语料来生成随机数据。其实就是一个样板，有了样板，Fuzzing 引擎就知道要生成什么类型的随机数据了。</p></blockquote>\n<ul>\n<li>基于种子语料库生成随机测试数据。运行命令如下：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ go test -fuzz&#x3D;Fuzz\nfuzz: elapsed: 0s, gathering baseline coverage: 0&#x2F;4 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 4&#x2F;4 completed, now fuzzing with 16 workers\nfuzz: elapsed: 3s, execs: 52911 (17633&#x2F;sec), new interesting: 1 (total: 5)\n\n...\n\nPASS\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;internal&#x2F;miniblog&#x2F;store        143.123s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是，执行模糊测试的时间是由开发者自己定的，如果你的代码非常强健，不管怎么更换随机数据，测试都能通过，那么 Fuzzing 将一直执行下去。除非找到了 error，或者你手动用 <code>Ctrl^C</code> 来停掉。</p>\n<p><code>go test</code> 跟模糊测试相关的参数还有以下 3 个：</p>\n<ul>\n<li><p><code>-fuzztime</code>: 执行的模糊目标在退出的时候要执行的总时间或者迭代次数，默认是永不结束；</p>\n</li>\n<li><p><code>-fuzzminimizetime</code>: 模糊目标在每次最少尝试时要执行的时间或者迭代次数，默认是 60 秒。你可以禁用最小化尝试，只需把这个参数设置为 0；</p>\n</li>\n<li><p><code>-parallel</code>: 同时执行的模糊化数量，默认是 <code>$GOMAXPROCS</code>。当前进行模糊化测试时设置 <code>-cpu</code>无效果。</p>\n</li>\n</ul>\n<h2 id=\"测试工具介绍\"><a href=\"#测试工具介绍\" class=\"headerlink\" title=\"测试工具介绍\"></a>测试工具介绍</h2><p>在编写测试用例的时候，我们还可以借助众多的优秀工具&#x2F;包，来协助我们快速编写高质量的测试用例。这些工具，按功能可以分为测试框架和 Mock 工具两类。测试框架，能够协助我们编写高质量的测试用例。Mock 工具，可以使我们在编写测试用例时，摆脱一些限制，使代码变得可测，提高代码的可测性。</p>\n<h3 id=\"测试框架\"><a href=\"#测试框架\" class=\"headerlink\" title=\"测试框架\"></a>测试框架</h3><ul>\n<li><a href=\"%22https://github.com/stretchr/testify%22\">Testify 框架</a>：Testify是 Go test 的预判工具，它能让你的测试代码变得更优雅和高效，测试结果也变得更详细。<code>miniblog</code> 项目中，<code>testify</code> 的使用案例见 <a href=\"%22https://github.com/marmotedu/miniblog/blob/feature/s23/internal/miniblog/store/helper_test.go%22\">helper_test.go</a>、<a href=\"%22https://github.com/marmotedu/miniblog/blob/feature/s23/internal/miniblog/biz/user/user_test.go%22\">user_test.go</a>、<a href=\"%22https://github.com/marmotedu/miniblog/blob/feature/s23/pkg/util/id/id_test.go%22\">id_test.go</a> 文件；</li>\n<li><a href=\"%22https://github.com/smartystreets/goconvey%22\">GoConvey 框架</a>：GoConvey 是一款针对 Go 语言的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性。</li>\n</ul>\n<h3 id=\"Mock-工具\"><a href=\"#Mock-工具\" class=\"headerlink\" title=\"Mock 工具\"></a>Mock 工具</h3><p>Mock 工具用的最多的是 Go 官方提供的 Mock 框架 <a href=\"%22https://github.com/golang/mock%22\">GoMock</a>。关于 GoMock 的使用方法，可参考：<a href=\"%22https://geektutu.com/post/quick-gomock.html%22\">Go Mock (gomock)简明教程</a>。</p>\n<p>此外，还有一些其他的优秀 Mock 工具可供我们使用。这些 Mock 工具分别用在不同的 Mock 场景中，常用的 Mock 工具如下：</p>\n<ul>\n<li><p><a href=\"%22https://github.com/DATA-DOG/go-sqlmock%22\">sqlmock</a>：可以用来模拟数据库连接。数据库是项目中比较常见的依赖，在遇到数据库依赖时都可以用它。</p>\n</li>\n<li><p><a href=\"%22https://github.com/jarcoal/httpmock%22\">httpmock</a>：可以用来 Mock HTTP 请求。</p>\n</li>\n<li><p><a href=\"%22https://github.com/bouk/monkey%22\">bouk&#x2F;monkey</a>：猴子补丁，能够通过替换函数指针的方式来修改任意函数的实现。如果 GoMock、sqlmock 和 httpmock 这几种方法都不能满足我们的需求，我们可以尝试用猴子补丁的方式来 Mock 依赖。可以这么说，猴子补丁提供了单元测试 Mock 依赖的最终解决方案。</p>\n</li>\n</ul>\n<h2 id=\"测试覆盖率\"><a href=\"#测试覆盖率\" class=\"headerlink\" title=\"测试覆盖率\"></a>测试覆盖率</h2><p>我们写单元测试的时候应该想得很全面，能够覆盖到所有的测试用例，但有时也会漏过一些 case，Go 提供了 <code>cover</code> 工具来统计测试覆盖率。</p>\n<p>可以通过以下 2 个命令来进行覆盖率测试：</p>\n<ul>\n<li><p><code>go test -coverprofile=cover.out</code>：在测试文件目录下运行测试并统计测试覆盖率；</p>\n</li>\n<li><p><code>go tool cover -func=cover.out</code>：分析覆盖率文件，可以看出哪些函数没有测试，哪些函数内部的分支没有测试完全，<code>cover</code> 工具会通过执行代码的行数与总行数的比例表示出覆盖率。</p>\n</li>\n</ul>\n<p><strong>测试覆盖率</strong></p>\n<p>执行以下命令进行测试：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ cd miniblog&#x2F;pkg&#x2F;util&#x2F;id\n$ go test -coverprofile&#x3D;cover.out\nPASS\ncoverage: 100.0% of statements\nok          github.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id        0.003s\n$ go tool cover -func&#x3D;cover.out\ngithub.com&#x2F;marmotedu&#x2F;miniblog&#x2F;pkg&#x2F;util&#x2F;id&#x2F;id.go:15:        GenShortID        100.0%\ntotal:                                                        (statements)        100.0%<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看到 <code>TestGenShortID</code> 函数测试覆盖率为 <code>100%</code>。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本节课简单介绍了如何用 testing 包，编写单元测试用例和性能测试用例。在实际的开发中，要养成编写单元测试用例的好习惯，在项目上线前，最好对一些业务逻辑比较复杂的函数做一些性能测试，提前发现性能问题。</p>\n<p>至于怎么去分析性能，比如查找耗时最久的函数等，我链接了郝林大神专业的分析方法 <a href=\"%22https://github.com/hyper0x/go_command_tutorial/blob/master/0.12.md%22\">go tool pprof</a>。更深的分析技巧需要你在实际开发中自己去探索。</p>\n","feature":true,"text":" 本文摘自《从零开发企业级 Go 应用》 在实际开发中，不仅要开发功能，更重要的是确保这些功能稳定可靠，并且拥有一个不错的性能，要确保这些，就要对代码进行测试。测试分为很多种，例如：功能测试、性能测试、集成测试、端到端测试、单元测试等。 对于开发者，需要执行的测试种类一般是单元测...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":9,"path":"api/tags/Golang.json"},{"name":"单元测试","slug":"单元测试","count":1,"path":"api/tags/单元测试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Go-%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%9F\"><span class=\"toc-text\">Go 语言如何编写测试用例？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Go-%E8%AF%AD%E8%A8%80%E6%B5%8B%E8%AF%95%E7%A7%8D%E7%B1%BB%E5%8F%8A%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Go 语言测试种类及用例编写方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">单元测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">性能测试</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">编写性能测试用例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">运行性能测试用例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E6%80%A7%E8%83%BD%E5%B9%B6%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%9B%BE\"><span class=\"toc-text\">查看性能并生成函数调用图</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">模糊测试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">测试工具介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">测试框架</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Mock-%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">Mock 工具</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87\"><span class=\"toc-text\">测试覆盖率</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a></li></ol>","author":{"name":"G","slug":"blog-author","avatar":"https://froggyfriends.mypinata.cloud/ipfs/QmaTJi8B2cH5QKiXz1XneEuDaL1WC71uuq2A1X9t4sfacT","link":"/","description":"一位正在重塑知识的技术人 <br />","socials":{"github":"https://github.com/gzwillyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/svg/telegram.svg","link":"https://t.me/gzwilly"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Go语言 之 项目设计(汇总)","uid":"fabd4c31ac9eef22c08bf05f6fc86b54","slug":"go-project-design-lint","date":"2023-02-03T03:05:50.000Z","updated":"2023-02-03T03:05:50.000Z","comments":true,"path":"api/articles/go-project-design-lint.json","keywords":null,"cover":"https://i.328888.xyz/2023/02/03/IKcpL.jpeg","text":" 本文摘自《从零开发企业级 Go 应用》 如何构建出一个完整的 Go 项目，并且尽可能地说明开发过程中我的思考。希望能够通过这些思考让你知道如何开发 Go 项目，并且了解其他开发者的开发思路。 项目研发流程介绍在动手撸代码之前，你最好先鸟瞰整个 Go 项目开发流程，通过对流程的了...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Golang","slug":"Golang","count":9,"path":"api/tags/Golang.json"},{"name":"项目设计","slug":"项目设计","count":1,"path":"api/tags/项目设计.json"}],"author":{"name":"G","slug":"blog-author","avatar":"https://froggyfriends.mypinata.cloud/ipfs/QmaTJi8B2cH5QKiXz1XneEuDaL1WC71uuq2A1X9t4sfacT","link":"/","description":"一位正在重塑知识的技术人 <br />","socials":{"github":"https://github.com/gzwillyy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/svg/telegram.svg","link":"https://t.me/gzwilly"}}}},"feature":true}}
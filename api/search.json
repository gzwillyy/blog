[{"id":"e386f25fe35d3cc208c03de6e86811c8","title":"Go语言项目开发规范 之 代码规范","content":"Go 代码开发规范在Go 项目开发中，一个好的编码规范可以极大的提高代码质量。为了帮你节省时间和精力，这里我整理了一份清晰、可直接套用的 Go 编码规范，供你参考。\n这份规范，是我参考了 Go 官方提供的编码规范，以及 Go 社区沉淀的一些比较合理的规范之后，加入自己的理解总结出的，它比很多公司内部的规范更全面，你掌握了，以后在面试大厂的时候，或者在大厂里写代码的时候，都会让人高看你一眼，觉得你code很专业。\n这份编码规范中包含代码风格、命名规范、注释规范、类型、控制结构、函数、GOPATH 设置规范、依赖管理和最佳实践九类规范。如果你觉得这些规范内容太多了，看完一遍也记不住，这完全没关系。你可以多看几遍，也可以在用到时把它翻出来，在实际应用中掌握。这篇特别放送的内容，更多是作为写代码时候的一个参考手册。\n1. 代码风格1.1 代码格式\n代码都必须用 gofmt 进行格式化。\n运算符和操作数之间要留空格。\n建议一行代码不超过120个字符，超过部分，请采用合适的换行方式换行。但也有些例外场景，例如import行、工具自动生成的代码、带tag的struct字段。\n文件长度不能超过800行。\n函数长度不能超过80行。\nimport规范\n代码都必须用goimports进行格式化（建议将代码Go代码编辑器设置为：保存时运行 goimports）。\n不要使用相对路径引入包，例如 import ../util/net 。\n包名称与导入路径的最后一个目录名不匹配时，或者多个相同包名冲突时，则必须使用导入别名。\n\n\n\n// bad\n\"github.com/dgrijalva/jwt-go/v4\"\n\n//good\njwt \"github.com/dgrijalva/jwt-go/v4\"\n- 导入的包建议进行分组，匿名包的引用使用一个新的分组，并对匿名包引用进行说明。\n\nimport (\n\t// go 标准包\n\t\"fmt\"\n\n\t// 第三方包\n    \"github.com/jinzhu/gorm\"\n    \"github.com/spf13/cobra\"\n    \"github.com/spf13/viper\"\n\n\t// 匿名包单独分组，并对匿名包引用进行说明\n    // import mysql driver\n    _ \"github.com/jinzhu/gorm/dialects/mysql\"\n\n\t// 内部包\n    v1 \"github.com/marmotedu/api/apiserver/v1\"\n    metav1 \"github.com/marmotedu/apimachinery/pkg/meta/v1\"\n    \"github.com/marmotedu/iam/pkg/cli/genericclioptions\"\n)\n\n1.2 声明、初始化和定义当函数中需要使用到多个变量时，可以在函数开始处使用var声明。在函数外部声明必须使用 var ，不要采用 := ，容易踩到变量的作用域的问题。\nvar (\n\tWidth  int\n\tHeight int\n)\n\n\n在初始化结构引用时，请使用&amp;T&#123;&#125;代替new(T)，以使其与结构体初始化一致。\n\n// bad\nsptr := new(T)\nsptr.Name = \"bar\"\n\n// good\nsptr := &amp;T&#123;Name: \"bar\"&#125;\n\n\nstruct 声明和初始化格式采用多行，定义如下。\n\ntype User struct&#123;\n    Username  string\n    Email     string\n&#125;\n\nuser := User&#123;\n\tUsername: \"belm\",\n\tEmail: \"nosbelm@qq.com\",\n&#125;\n\n\n相似的声明放在一组，同样适用于常量、变量和类型声明。\n\n// bad\nimport \"a\"\nimport \"b\"\n\n// good\nimport (\n  \"a\"\n  \"b\"\n)\n\n\n尽可能指定容器容量，以便为容器预先分配内存，例如：\n\nv := make(map[int]string, 4)\nv := make([]string, 0, 4)\n\n\n在顶层，使用标准var关键字。请勿指定类型，除非它与表达式的类型不同。\n\n// bad\nvar _s string = F()\n\nfunc F() string &#123; return \"A\" &#125;\n\n// good\nvar _s = F()\n// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型\n// 还是那种类型\n\nfunc F() string &#123; return \"A\" &#125;\n\n\n对于未导出的顶层常量和变量，使用_作为前缀。\n\n// bad\nconst (\n  defaultHost = \"127.0.0.1\"\n  defaultPort = 8080\n)\n\n// good\nconst (\n  _defaultHost = \"127.0.0.1\"\n  _defaultPort = 8080\n)\n\n\n嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。\n\n// bad\ntype Client struct &#123;\n  version int\n  http.Client\n&#125;\n\n// good\ntype Client struct &#123;\n  http.Client\n\n  version int\n&#125;\n\n1.3 错误处理\nerror作为函数的值返回，必须对error进行处理，或将返回值赋值给明确忽略。对于defer xx.Close()可以不用显式处理。\n\nfunc load() error &#123;\n\t// normal code\n&#125;\n\n// bad\nload()\n\n// good\n _ = load()\n\n\nerror作为函数的值返回且有多个返回值的时候，error必须是最后一个参数。\n\n// bad\nfunc load() (error, int) &#123;\n\t// normal code\n&#125;\n\n// good\nfunc load() (int, error) &#123;\n\t// normal code\n&#125;\n\n\n尽早进行错误处理，并尽早返回，减少嵌套。\n\n// bad\nif err != nil &#123;\n\t// error code\n&#125; else &#123;\n\t// normal code\n&#125;\n\n// good\nif err != nil &#123;\n\t// error handling\n\treturn err\n&#125;\n// normal code\n\n\n如果需要在 if 之外使用函数调用的结果，则应采用下面的方式。\n\n// bad\nif v, err := foo(); err != nil &#123;\n\t// error handling\n&#125;\n\n// good\nv, err := foo()\nif err != nil &#123;\n\t// error handling\n&#125;\n\n\n错误要单独判断，不与其他逻辑组合判断。\n\n// bad\nv, err := foo()\nif err != nil || v  == nil &#123;\n\t// error handling\n\treturn err\n&#125;\n\n// good\nv, err := foo()\nif err != nil &#123;\n\t// error handling\n\treturn err\n&#125;\n\nif v == nil &#123;\n\t// error handling\n\treturn errors.New(\"invalid value v\")\n&#125;\n\n\n如果返回值需要初始化，则采用下面的方式。\n\nv, err := f()\nif err != nil &#123;\n    // error handling\n    return // or continue.\n&#125;\n\n\n错误描述建议\n错误描述用小写字母开头，结尾不要加标点符号，例如：// bad\nerrors.New(\"Redis connection failed\")\nerrors.New(\"redis connection failed.\")\n\n// good\nerrors.New(\"redis connection failed\")\n告诉用户他们可以做什么，而不是告诉他们不能做什么。\n当声明一个需求时，用must 而不是should。例如，must be greater than 0、must match regex &#39;[a-z]+&#39;。\n当声明一个格式不对时，用must not。例如，must not contain。\n当声明一个动作时用may not。例如，may not be specified when otherField is empty、only name may be specified。\n引用文字字符串值时，请在单引号中指示文字。例如，ust not contain &#39;..&#39;。\n当引用另一个字段名称时，请在反引号中指定该名称。例如，must be greater than request。\n指定不等时，请使用单词而不是符号。例如，must be less than 256、must be greater than or equal to 0 (不要用 larger than、bigger than、more than、higher than)。\n指定数字范围时，请尽可能使用包含范围。\n建议 Go 1.13 以上，error 生成方式为 fmt.Errorf(&quot;module xxx: %w&quot;, err)。\n\n\n\n1.4 panic处理\n在业务逻辑处理中禁止使用panic。\n在main包中，只有当程序完全不可运行时使用panic，例如无法打开文件、无法连接数据库导致程序无法正常运行。\n在main包中，使用 log.Fatal 来记录错误，这样就可以由log来结束程序，或者将panic抛出的异常记录到日志文件中，方便排查问题。\n可导出的接口一定不能有panic。\n包内建议采用error而不是panic来传递错误。\n\n1.5 单元测试\n单元测试文件名命名规范为 example_test.go。\n每个重要的可导出函数都要编写测试用例。\n因为单元测试文件内的函数都是不对外的，所以可导出的结构体、函数等可以不带注释。\n如果存在 func (b *Bar) Foo ，单测函数可以为 func TestBar_Foo。\n\n1.6 类型断言失败处理\ntype assertion 的单个返回值针对不正确的类型将产生 panic。请始终使用 “comma ok”的惯用法。\n\n// bad\nt := n.(int)\n\n// good\nt, ok := n.(int)\nif !ok &#123;\n\t// error handling\n&#125;\n\n2. 命名规范命名规范是代码规范中非常重要的一部分，一个统一的、短小的、精确的命名规范可以大大提高代码的可读性，也可以借此规避一些不必要的Bug。\n2.1 包命名\n包名必须和目录名一致，尽量采取有意义、简短的包名，不要和标准库冲突。\n包名全部小写，没有大写或下划线，使用多级目录来划分层级。\n项目名可以通过中划线来连接多个单词。\n包名以及包所在的目录名，不要使用复数，例如，是net/url，而不是net/urls。\n不要用 common、util、shared 或者 lib 这类宽泛的、无意义的包名。\n包名要简单明了，例如 net、time、log。\n\n2.2 函数命名\n函数名采用驼峰式，首字母根据访问控制决定使用大写或小写，例如：MixedCaps或者mixedCaps。\n代码生成工具自动生成的代码(如xxxx.pb.go)和为了对相关测试用例进行分组，而采用的下划线(如TestMyFunction_WhatIsBeingTested)排除此规则。\n\n2.3 文件命名\n文件名要简短有意义。\n文件名应小写，并使用下划线分割单词。\n\n2.4 结构体命名\n采用驼峰命名方式，首字母根据访问控制决定使用大写或小写，例如MixedCaps或者mixedCaps。\n结构体名不应该是动词，应该是名词，比如 Node、NodeSpec。\n避免使用Data、Info这类无意义的结构体名。\n结构体的声明和初始化应采用多行，例如：\n\n// User 多行声明\ntype User struct &#123;\n    Name  string\n    Email string\n&#125;\n\n// 多行初始化\nu := User&#123;\n    UserName: \"belm\",\n    Email:    \"nosbelm@qq.com\",\n&#125;\n\n2.5 接口命名\n接口命名的规则，基本和结构体命名规则保持一致：\n单个函数的接口名以 “er””作为后缀（例如Reader，Writer），有时候可能导致蹩脚的英文，但是没关系。\n两个函数的接口名以两个函数名命名，例如ReadWriter。\n三个以上函数的接口名，类似于结构体名。\n\n\n\n例如：\n&#x2F;&#x2F; Seeking to an offset before the start of the file is an error.\n&#x2F;&#x2F; Seeking to any positive offset is legal, but the behavior of subsequent\n&#x2F;&#x2F; I&#x2F;O operations on the underlying object is implementation-dependent.\ntype Seeker interface &#123;\n    Seek(offset int64, whence int) (int64, error)\n&#125;\n\n&#x2F;&#x2F; ReadWriter is the interface that groups the basic Read and Write methods.\ntype ReadWriter interface &#123;\n    Reader\n    Writer\n&#125;\n\n2.6 变量命名\n变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。\n在相对简单（对象数量少、针对性强）的环境中，可以将一些名称由完整单词简写为单个字母，例如：\nuser 可以简写为 u；\nuserID 可以简写 uid。\n\n\n特有名词时，需要遵循以下规则：\n如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient。\n其他情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID。\n\n\n\n下面列举了一些常见的特有名词。\n&#x2F;&#x2F; A GonicMapper that contains a list of common initialisms taken from golang&#x2F;lint\nvar LintGonicMapper &#x3D; GonicMapper&#123;\n    &quot;API&quot;:   true,\n    &quot;ASCII&quot;: true,\n    &quot;CPU&quot;:   true,\n    &quot;CSS&quot;:   true,\n    &quot;DNS&quot;:   true,\n    &quot;EOF&quot;:   true,\n    &quot;GUID&quot;:  true,\n    &quot;HTML&quot;:  true,\n    &quot;HTTP&quot;:  true,\n    &quot;HTTPS&quot;: true,\n    &quot;ID&quot;:    true,\n    &quot;IP&quot;:    true,\n    &quot;JSON&quot;:  true,\n    &quot;LHS&quot;:   true,\n    &quot;QPS&quot;:   true,\n    &quot;RAM&quot;:   true,\n    &quot;RHS&quot;:   true,\n    &quot;RPC&quot;:   true,\n    &quot;SLA&quot;:   true,\n    &quot;SMTP&quot;:  true,\n    &quot;SSH&quot;:   true,\n    &quot;TLS&quot;:   true,\n    &quot;TTL&quot;:   true,\n    &quot;UI&quot;:    true,\n    &quot;UID&quot;:   true,\n    &quot;UUID&quot;:  true,\n    &quot;URI&quot;:   true,\n    &quot;URL&quot;:   true,\n    &quot;UTF8&quot;:  true,\n    &quot;VM&quot;:    true,\n    &quot;XML&quot;:   true,\n    &quot;XSRF&quot;:  true,\n    &quot;XSS&quot;:   true,\n&#125;\n\n\n若变量类型为bool类型，则名称应以Has，Is，Can或Allow开头，例如：\n\nvar hasConflict bool\nvar isExist bool\nvar canManage bool\nvar allowGitHook bool\n\n\n局部变量应当尽可能短小，比如使用buf指代buffer，使用i指代index。\n代码生成工具自动生成的代码可排除此规则(如xxx.pb.go里面的Id)\n\n2.7 常量命名\n常量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。\n如果是枚举类型的常量，需要先创建相应类型：\n\n// Code defines an error code type.\ntype Code int\n\n// Internal errors.\nconst (\n    // ErrUnknown - 0: An unknown error occurred.\n    ErrUnknown Code = iota\n    // ErrFatal - 1: An fatal error occurred.\n    ErrFatal\n)\n\n2.8 Error的命名\nError类型应该写成FooError的形式。\n\ntype ExitError struct &#123;\n\t// ....\n&#125;\n\n\nError变量写成ErrFoo的形式。\n\nvar ErrFormat = errors.New(\"unknown format\")\n\n3. 注释规范\n每个可导出的名字都要有注释，该注释对导出的变量、函数、结构体、接口等进行简要介绍。\n全部使用单行注释，禁止使用多行注释。\n和代码的规范一样，单行注释不要过长，禁止超过 120 字符，超过的请使用换行展示，尽量保持格式优雅。\n注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾，格式为 // 名称 描述.。例如：\n\n// bad\n// logs the flags in the flagset.\nfunc PrintFlags(flags *pflag.FlagSet) &#123;\n\t// normal code\n&#125;\n\n// good\n// PrintFlags logs the flags in the flagset.\nfunc PrintFlags(flags *pflag.FlagSet) &#123;\n\t// normal code\n&#125;\n\n\n所有注释掉的代码在提交code review前都应该被删除，否则应该说明为什么不删除，并给出后续处理建议。\n\n在多段注释之间可以使用空行分隔加以区分，如下所示：\n\n\n// Package superman implements methods for saving the world.\n//\n// Experience has shown that a small number of procedures can prove\n// helpful when attempting to save the world.\npackage superman\n\n3.1 包注释\n每个包都有且仅有一个包级别的注释。\n包注释统一用 &#x2F;&#x2F; 进行注释，格式为 // Package 包名 包描述，例如：\n\n// Package genericclioptions contains flags which can be added to you command, bound, completed, and produce\n// useful helper functions.\npackage genericclioptions\n\n3.2 变量&#x2F;常量注释\n每个可导出的变量&#x2F;常量都必须有注释说明，格式为// 变量名 变量描述，例如：\n\n// ErrSigningMethod defines invalid signing method error.\nvar ErrSigningMethod = errors.New(\"Invalid signing method\")\n\n出现大块常量或变量定义时，可在前面注释一个总的说明，然后在每一行常量的前一行或末尾详细注释该常量的定义，例如：// Code must start with 1xxxxx.\nconst (\n    // ErrSuccess - 200: OK.\n    ErrSuccess int = iota + 100001\n\n    // ErrUnknown - 500: Internal server error.\n    ErrUnknown\n\n    // ErrBind - 400: Error occurred while binding the request body to the struct.\n    ErrBind\n\n    // ErrValidation - 400: Validation failed.\n    ErrValidation\n)\n\n3.3 结构体注释\n每个需要导出的结构体或者接口都必须有注释说明，格式为 // 结构体名 结构体描述.。\n结构体内的可导出成员变量名，如果意义不明确，必须要给出注释，放在成员变量的前一行或同一行的末尾。例如：\n\n// User represents a user restful resource. It is also used as gorm model.\ntype User struct &#123;\n    // Standard object's metadata.\n    metav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n    Nickname string `json:\"nickname\" gorm:\"column:nickname\"`\n    Password string `json:\"password\" gorm:\"column:password\"`\n    Email    string `json:\"email\" gorm:\"column:email\"`\n    Phone    string `json:\"phone\" gorm:\"column:phone\"`\n    IsAdmin  int    `json:\"isAdmin,omitempty\" gorm:\"column:isAdmin\"`\n&#125;\n\n3.4 方法注释每个需要导出的函数或者方法都必须有注释，格式为&#x2F;&#x2F; 函数名 函数描述.，例如：\n// BeforeUpdate run before update database record.\nfunc (p *Policy) BeforeUpdate() (err error) &#123;\n\t// normal code\n\treturn nil\n&#125;\n\n3.5 类型注释\n每个需要导出的类型定义和类型别名都必须有注释说明，格式为 // 类型名 类型描述.，例如：\n\n// Code defines an error code type.\ntype Code int\n\n4. 类型4.1 字符串\n空字符串判断。\n\n// bad\nif s == \"\" &#123;\n    // normal code\n&#125;\n\n// good\nif len(s) == 0 &#123;\n    // normal code\n&#125;\n\n\n[]byte&#x2F;string相等比较。\n\n// bad\nvar s1 []byte\nvar s2 []byte\n...\nbytes.Equal(s1, s2) == 0\nbytes.Equal(s1, s2) != 0\n\n// good\nvar s1 []byte\nvar s2 []byte\n...\nbytes.Compare(s1, s2) == 0\nbytes.Compare(s1, s2) != 0\n\n\n复杂字符串使用raw字符串避免字符转义。\n\n// bad\nregexp.MustCompile(\"\\\\.\")\n\n// good\nregexp.MustCompile(`\\.`)\n\n4.2 切片\n空slice判断。\n\n// bad\nif len(slice) = 0 &#123;\n    // normal code\n&#125;\n\n// good\nif slice != nil &amp;&amp; len(slice) == 0 &#123;\n    // normal code\n&#125;\n\n上面判断同样适用于map、channel。\n\n声明slice。\n\n// bad\ns := []string&#123;&#125;\ns := make([]string, 0)\n\n// good\nvar s []string\n\n\nslice复制。\n\n// bad\nvar b1, b2 []byte\nfor i, v := range b1 &#123;\n   b2[i] = v\n&#125;\nfor i := range b1 &#123;\n   b2[i] = b1[i]\n&#125;\n\n// good\ncopy(b2, b1)\n\n\nslice新增。\n\n// bad\nvar a, b []int\nfor _, v := range a &#123;\n    b = append(b, v)\n&#125;\n\n// good\nvar a, b []int\nb = append(b, a...)\n\n4.3 结构体\nstruct初始化。\n\nstruct以多行格式初始化。\ntype user struct &#123;\n\tId   int64\n\tName string\n&#125;\n\nu1 := user&#123;100, \"Colin\"&#125;\n\nu2 := user&#123;\n    Id:   200,\n    Name: \"Lex\",\n&#125;\n\n5. 控制结构5.1 if\nif 接受初始化语句，约定如下方式建立局部变量。\n\nif err := loadConfig(); err != nil &#123;\n\t// error handling\n\treturn err\n&#125;\n\n\nif 对于bool类型的变量，应直接进行真假判断。\n\nvar isAllow bool\nif isAllow &#123;\n\t// normal code\n&#125;\n\n5.2 for\n采用短声明建立局部变量。\n\nsum := 0\nfor i := 0; i &lt; 10; i++ &#123;\n    sum += 1\n&#125;\n\n\n不要在 for 循环里面使用 defer，defer只有在函数退出时才会执行。\n\n// bad\nfor file := range files &#123;\n\tfd, err := os.Open(file)\n\tif err != nil &#123;\n\t\treturn err\n\t&#125;\n\tdefer fd.Close()\n\t// normal code\n&#125;\n\n// good\nfor file := range files &#123;\n\tfunc() &#123;\n\t\tfd, err := os.Open(file)\n\t\tif err != nil &#123;\n\t\t\treturn err\n\t\t&#125;\n\t\tdefer fd.Close()\n\t\t// normal code\n\t&#125;()\n&#125;\n\n5.3 range\n如果只需要第一项（key），就丢弃第二个。\n\nfor key := range keys &#123;\n// normal code\n&#125;\n\n\n如果只需要第二项，则把第一项置为下划线。\n\nsum := 0\nfor _, value := range array &#123;\n    sum += value\n&#125;\n\n5.4 switch\n必须要有default。\n\nswitch os := runtime.GOOS; os &#123;\n    case \"linux\":\n        fmt.Println(\"Linux.\")\n    case \"darwin\":\n        fmt.Println(\"OS X.\")\n    default:\n        fmt.Printf(\"%s.\\n\", os)\n&#125;\n\n5.5 goto\n业务代码禁止使用 goto 。\n框架或其他底层源码尽量不用。\n\n6. 函数\n传入变量和返回变量以小写字母开头。\n函数参数个数不能超过5个。\n函数分组与顺序\n函数应按粗略的调用顺序排序。\n同一文件中的函数应按接收者分组。\n尽量采用值传递，而非指针传递。\n传入参数是 map、slice、chan、interface ，不要传递指针。\n\n6.1 函数参数\n如果函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其他情况不建议使用命名返回，例如：\n\nfunc coordinate() (x, y float64, err error) &#123;\n\t// normal code\n&#125;\n\n传入变量和返回变量都以小写字母开头。\n尽量用值传递，非指针传递。\n参数数量均不能超过5个。\n多返回值最多返回三个，超过三个请使用 struct。\n\n6.2 defer\n当存在资源创建时，应紧跟defer释放资源(可以大胆使用defer，defer在Go1.14版本中，性能大幅提升，defer的性能损耗即使在性能敏感型的业务中，也可以忽略)。\n先判断是否错误，再defer释放资源，例如：\n\nrep, err := http.Get(url)\nif err != nil &#123;\n    return err\n&#125;\n\ndefer resp.Body.Close()\n\n6.3 方法的接收器\n推荐以类名第一个英文首字母的小写作为接收器的命名。\n接收器的命名在函数超过20行的时候不要用单字符。\n接收器的命名不能采用me、this、self这类易混淆名称。\n\n6.4 嵌套\n嵌套深度不能超过4层。\n\n6.5 变量命名\n变量声明尽量放在变量第一次使用的前面，遵循就近原则。\n如果魔法数字出现超过两次，则禁止使用，改用一个常量代替，例如：\n\n// PI ...\nconst Prise = 3.14\n\nfunc getAppleCost(n float64) float64 &#123;\n\treturn Prise * n\n&#125;\n\nfunc getOrangeCost(n float64) float64 &#123;\n\treturn Prise * n\n&#125;\n\n7. GOPATH 设置规范\nGo 1.11 之后，弱化了 GOPATH 规则，已有代码（很多库肯定是在1.11之前建立的）肯定符合这个规则，建议保留 GOPATH 规则，便于维护代码。\n建议只使用一个 GOPATH，不建议使用多个 GOPATH。如果使用多个GOPATH，编译生效的 bin 目录是在第一个 GOPATH 下。\n\n8. 依赖管理\nGo 1.11 以上必须使用 Go Modules。\n使用Go Modules作为依赖管理的项目时，不建议提交vendor目录。\n使用Go Modules作为依赖管理的项目时，必须提交go.sum文件。\n\n9. 最佳实践\n尽量少用全局变量，而是通过参数传递，使每个函数都是“无状态”的。这样可以减少耦合，也方便分工和单元测试。\n在编译时验证接口的符合性，例如：\n\ntype LogHandler struct &#123;\n  h   http.Handler\n  log *zap.Logger\n&#125;\nvar _ http.Handler = LogHandler&#123;&#125;\n\n服务器处理请求时，应该创建一个context，保存该请求的相关信息（如requestID），并在函数调用链中传递。\n\n9.1 性能\nstring 表示的是不可变的字符串变量，对 string 的修改是比较重的操作，基本上都需要重新申请内存。所以，如果没有特殊需要，需要修改时多使用 []byte。\n优先使用 strconv 而不是 fmt。\n\n9.2 注意事项\nappend 要小心自动分配内存，append 返回的可能是新分配的地址。\n如果要直接修改 map 的 value 值，则 value 只能是指针，否则要覆盖原来的值。\nmap 在并发中需要加锁。\n编译过程无法检查 interface{} 的转换，只能在运行时检查，小心引起 panic。\n\n总结这里向你介绍了九类常用的编码规范。但今天的最后，我要在这里提醒你一句：规范是人定的，你也可以根据需要，制定符合你项目的规范，但同时我也建议你采纳这些业界沉淀下来的规范，并通过工具来确保规范的执行。\n","slug":"go-code-lint","date":"2023-02-02T12:50:39.000Z","categories_index":"Golang","tags_index":"开发规范,Golang,代码规范","author_index":"G"},{"id":"a5920cb23f39d78f08d5111f3bca2f52","title":"Go语言项目开发规范 之 Commit规范","content":"Commit 规范Conventional Commits 规范。\n\n\n\n\n\n\n\n\n\n中文翻译版：Conventional Commits：一份让代码提交记录人机友好的规范\n","slug":"go-commit-lint","date":"2023-02-02T12:50:39.000Z","categories_index":"Golang","tags_index":"开发规范,Golang,Commit规范","author_index":"G"},{"id":"667b05d95cb0526d39ac5a44681ede14","title":"Go语言项目开发规范 之 接口规范","content":"接口规范OpenAPI 3.0 接口规范。\n\n\n\n\n\n\n\n\n\n中文翻译版：开放 API 规范中文翻译\n","slug":"go-api-lint","date":"2023-02-02T12:50:39.000Z","categories_index":"Golang","tags_index":"开发规范,Golang,接口规范","author_index":"G"},{"id":"d9d9f163b27a172616433f2b1dbfa9a5","title":"Go语言项目开发规范 之 目录规范","content":"目录规范project-layout 目录规范。\n","slug":"go-directory-lint","date":"2023-02-02T12:50:39.000Z","categories_index":"Golang","tags_index":"开发规范,Golang,目录规范","author_index":"G"},{"id":"eaecbf1374ac3af5317abae9d46a227d","title":"Go语言项目开发规范 之 错误规范","content":"错误码规范错误码是用户定位及解决问题的重要手段之一，当应用发生异常时，用户根据错误码及文档中的错误码描述和解决方案就可以快速定位并解决问题。\n错误码命名规范\n遵循驼峰命名法；\n错误码分为两级。例如，InvalidParameter.BindError，以 . 号分隔。其中，第一级错误码为平台级，第二级错误码为资源级别，可根据场景自定义；\n第二级错误码只能使用英文字母或数字（[a-zA-Z0-9]），应使用英文单词规范拼写、规范缩写、RFC 术语缩写等；\n错误码应避免同一语义多种定义，例如：InvalidParameter.ErrorBind, InvalidParameter.BindError。\n\n第一级公共错误码| 错误码 | 错误描述 | 错误类型 || —- | —- || InternalError | 内部错误 | 1 || InvalidParameter | 参数错误（包括参数类型、格式、值等错误） | 0 || AuthFailure | 认证 &#x2F; 授权错误 | 0 || ResourceNotFound | 资源不存在 | 0 || FailedOperation | 操作失败 | 2 |\n\n\n\n\n\n\n\n\n\n错误类型：0 代表客户端，1 代表服务端，2 代表客户端 &#x2F; 服务端。\n","slug":"go-errorcode-lint","date":"2023-02-02T12:50:39.000Z","categories_index":"Golang","tags_index":"开发规范,Golang,错误规范","author_index":"G"},{"id":"b81759ce043682066ca823838f04004e","title":"Go语言项目开发规范 之 日志规范","content":"日志规范日志规范\n日志包统一使用 github.com/marmotedu/miniblog/internal/pkg/log;\n使用结构化的日志打印格式：log.Infow, log.Warnw, log.Errorw 等; 例如：log.Infow(&quot;Update post function called&quot;);\n日志均以大写开头，结尾不跟 .，例如：log.Infow(&quot;Update post function called&quot;);\n使用过去时，例如：Could not delete B 而不是 Cannot delete B;\n遵循日志级别规范：\nDebug 级别的日志使用 log.Debugw;\nInfo 级别的日志使用 log.Infow;\nWarning 级别的日志使用 log.Warnw;\nError 级别的日志使用 log.Errorw;\nPanic 级别的日志使用 log.Panicw;\nFatal 级别的日志使用 log.Fatalw.\n\n\n日志设置：\n开发测试环境：日志级别设置为 debug、日志格式可根据需要设置为 console &#x2F; json、开启 caller；\n生产环境：日志级别设置为 info、日志格式设置为 json、开启 caller。（注意：上线初期，为了方便现网排障，日志级别可以设置为 debug）\n\n\n在记录日志时，不要输出一些敏感信息，例如密码、密钥等。\n如果在具有 context.Context 参数的函数&#x2F;方法中，调用日志函数，建议使用 log.L(ctx).Infow() 进行日志记录。\n\n","slug":"go-logging-lint","date":"2023-02-02T12:50:39.000Z","categories_index":"Golang","tags_index":"开发规范,Golang,日志规范","author_index":"G"},{"id":"d66d0f629c4193825a58a03816bc2031","title":"Go语言项目开发规范 之 版本规范","content":"版本规范语义化版本 2.0.0 规范。\n","slug":"go-version-lint","date":"2023-02-02T12:50:39.000Z","categories_index":"Golang","tags_index":"开发规范,Golang,版本规范","author_index":"G"},{"id":"07709a5ec8fca245e3ed20c42a15171e","title":"Mysql 之 使用 Prometheus 和 Grafana 监控 MySQL 性能","content":"\n\n\n\n\n\n\n\n\n请注意，这只是一个简单搭建教程，具体应用还需要根据实际情况来调整。\n基础环境\n\n\n环境&#x2F;组件\n版本\n\n\n\nMac M1虚拟机\nCentos8\n\n\nPrometheus\n2.41.0\n\n\nGrafana\n9.3.2\n\n\n1. Prometheus 安装与配置Prometheus 下载Prometheus 的官方网站https:&#x2F;&#x2F;prometheus.io\n\nPrometheus 安装Prometheus 安装的命令行语句cd ~\nmkdir prometheus &amp;&amp; cd prometheus\nwegt https://github.com/prometheus/prometheus/releases/download/v2.41.0/prometheus-2.41.0.linux-arm64.tar.gz\ntar -zxvf prometheus-2.41.0.linux-arm64.tar.gz\n./prometheus\n\n\n\n2. Grafana 安装与配置Grafana 下载Grafana 的官方网站https:&#x2F;&#x2F;grafana.com\n\nGrafana 安装Grafana 安装的命令行语句docker pull grafana&#x2F;grafana-oss:9.3.2-ubuntu@sha256:e76c86b351aadc13a748ac05937110a69d659b426ca59e0d824a325170ca75fd\ndocker run -d --net host --name&#x3D;grafana -e &quot;GF_INSTALL_PLUGINS&#x3D;grafana-clock-panel,grafana-simple-json-datasource&quot; -p 3000:3000 77a68ddee903\n\n3. mysql_exporter 安装与配置mysql_exporter 下载wget https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;mysqld_exporter&#x2F;releases&#x2F;download&#x2F;v0.14.0&#x2F;mysqld_exporter-0.14.0.linux-arm64.tar.gz\ntar -zxvf mysqld_exporter-0.14.0.linux-arm64.tar.gz\ncd mysqld_exporter-0.14.0.linux-arm64\nvim .my.cnf\n\n[client]\nhost&#x3D;127.0.0.1\nport&#x3D;3306\nuser&#x3D;mysqld_exporter\npassword&#x3D;mysqld_exporter\n\n.&#x2F;mysqld_exporter --config.my-cnf&#x3D;&#x2F;root&#x2F;prometheus&#x2F;mysql_exporter&#x2F;mysqld_exporter-0.14.0.linux-arm64&#x2F;.my.cnf\n\nvi &#x2F;root&#x2F;prometheus&#x2F;prometheus-2.41.0.linux-arm64&#x2F;prometheus.yml\n\n- job_name: &#39;mysqld-node&#39;\n    static_configs:\n    - targets: [&#39;192.168.1.235:9104&#39;]\n      labels:\n        instance: mysqld-node1\n\n\nGrafana 配置监控面板Grafana 中创建 mysql_exporter 监控面板导入mysqld_exporter仪表板 ID 7362 ,修改名称 加载\n\n","slug":"mysql-prometheus-grafana-build","date":"2023-01-22T13:58:26.000Z","categories_index":"Mysql","tags_index":"Prometheus,Grafana,监控","author_index":"G"},{"id":"8fee980f49138056ea0028cf01eac4d6","title":"微服务 之 高可用保障 - 链路追踪、熔断、限流、降级","content":"微服务是一种将应用程序作为独立服务的集合结构的架构风格。这些服务通过API互相通信，设计为具有高度的可扩展性、灵活性和弹性。为了保证微服务环境的高可用性，实施几个关键策略是非常重要的，包括链路追踪、熔断、限流和降级。\n链路追踪链路追踪是追踪请求在应用中穿过不同微服务的路径的能力。这对于故障排除和调试问题以及监测性能非常重要。\n通过实施链路追踪，开发人员可以快速识别问题的根源并采取纠正措施。这也可以通过优化单个服务来提高应用的整体性能。\n熔断熔断是一种防止微服务因故障导致整个应用瘫痪的技术。当一个服务不可用时，熔断器会自动打开，阻止请求传递到该服务，并返回预定义的响应。\n通过实施熔断，开发人员可以保证即使一个服务出现故障，整个应用也不会停止工作。这有助于保证整个应用的可用性和稳定性。\n限流限流是一种限制单位时间内请求数量的技术。当请求速率超过预定的阈值时，限流器会阻止进一步的请求，以避免服务器过载。\n通过实施限流，开发人员可以保证服务器性能不会因请求速率过快而受到影响。这有助于保证应用的稳定性和可用性。\n降级降级是一种在服务不可用时降低功能级别的技术。当一个服务不可用时，降级策略会自动启用，以降低应用的功能级别。\n通过实施降级，开发人员可以在服务不可用时保证应用仍然可以继续提供部分功能。这有助于保证应用的可用性。\n","slug":"micro-high-availability","date":"2023-01-12T08:40:29.000Z","categories_index":"Micro","tags_index":"链路追踪,熔断,限流,降级","author_index":"G"},{"id":"04abdce79ce1414cc92810e537b53ae4","title":"微服务 之 服务雪崩","content":"服务雪崩现象从服务雪崩开始讲起！假设存在如下调用链 :\nService A  -&gt;  Service B  -&gt;  Service C\n\n此时，Service A的流量波动很大，流量经常会突然性增加！\n\n那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求\n\n如果Service C因为抗不住请求，变得不可用.那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用\n\n紧接着，Service A也会不可用\n\n一个服务失败，终将会导致整条链路的服务都失败，我们称之为服务雪崩。\n那么，服务熔断和服务降级就可以视为解决服务雪崩的手段之一。\n服务熔断什么是服务熔断？\n\n\n\n\n\n\n\n\n\n服务熔断：当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，        不再继续调用目标服务，直接返回，快速释放资源。        如果目标服务情况好转则恢复调用。        需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计\n服务降级这里有两种场景:\n\n当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度！\n当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！\n\n可以这么理解:\n\n服务降级有很多种降级方式！如开关降级、限流降级、熔断降级! \n服务熔断属于降级方式的一种！\n\n\n\n\n\n\n\n\n\n\n可能有的人不服，觉得熔断是熔断、降级是降级，分明是两回事啊！其实不然，因为从实现上来说，熔断和降级必定是一起出现。\n因为当发生下游服务不可用的情况，这个时候为了对最终用户负责，就需要进入上游的降级逻辑了。\n因此，将熔断降级视为降级方式的一种，也是可以说的通的！\n撇开框架，以最简单的代码来说明！上游代码如下:\ntry&#123;\n    //调用下游的helloWorld服务\n    xxRpc.helloWorld();\n&#125;catch(Exception e)&#123;\n    //因为熔断，所以调不通\n    doSomething();\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意看，下游的helloWorld服务因为熔断而调不通。此时上游服务就会进入catch里头的代码块，那么catch里头执行的逻辑，你就可以理解为降级逻辑!\n\n\n\n\n\n\n\n\n\n服务降级大多是属于一种业务级别的处理。做法很简单，做个开关，然后将开关放配置中心！在配置中心更改开关，决定哪些服务进行降级。至于配置变动后，应用怎么监控到配置发生了变动，这就不是本文该讨论的范围。那么，在应用程序中部下开关的这个过程，业内也有一个名词，称为埋点！\n那接下来最关键的一个问题，哪些业务需要埋点？ \n\n简化执行流程 自己梳理出核心业务流程和非核心业务流程。然后在非核心业务流程上加上开关，一旦发现系统扛不住，关掉开关，结束这些次要流程。\n\n关闭次要功能 一个微服务下肯定有很多功能，那自己区分出主要功能和次要功能。然后次要功能加上开关，需要降级的时候，把次要功能关了吧！\n\n降低一致性 假设，你在业务上发现执行流程没法简化了，愁啊！也没啥次要功能可以关了，桑心啊！那只能降低一致性了，即将核心业务流程的同步改异步，将强一致性改最终一致性！\n\n\n这些都是手动降级，一般需要降级的场景，都是可以预见的，例如某某活动\n\n","slug":"micro-avalanche","date":"2023-01-12T06:45:02.000Z","categories_index":"Micro","tags_index":"服务雪崩","author_index":"G"},{"id":"9e30b559063f2ec93bec62f6225da283","title":"微服务 之 幂等性机制","content":"http请求的类型：\nget 获取商品信息， 这个会引起商品的数据的变化吗？\npost 比较常见，这种接口需要考虑到幂等性\nput\n没有幂等的问题的情况：把1号商品的价格改为200，网络返回的时候抖动了，重试 ,第二次接口还是会把1号商品的价格改为200 \n出现幂等性问题的情况：\n购物车中的商品，调用一次 这个商品的数量加一\n第一次调用 原本的值 10 之后价格变为11 - 但是返回的时候出现了网络抖动 \n第二次发送 原本的值 11 之后价格变为12 - 但是返回的时候出现了网络抖动，\n第三次发送 原本的值 12 之后价格变为13 - 但是返回的时候出现了网络抖动\n\n\n\n\ndelete 一般不具备幂等性的要求，第一次调用 删除数据，第二次调用 还是删除当前的数据\n\n\n\n\n\n\n\n\n\n\n现在假设，你自己开发了一个支付宝，然后别人在二维码支付页面，先支付了,结果由于网络问题，当前页面一直没有刷新，就让人以为我没有支付，然后我就再次扫码支付，这下完蛋了：你扣了两次款。\n超时 重试 幂等性机制超时  timeout是为了保护服务，避免consumer服务因为provider 响应慢而也变得响应很慢，这样consumer可以尽量保持原有的性能。\n重试  如果provider只是偶尔抖动，那么超时后直接放弃，不做后续处理，就会导致当前请求错误，也会带来业务方面的损失。\n  对于这种偶尔抖动，可以在超时后重试一下，重试如果正常返回了，那么这次请求就被挽救了，能够正常给前端返回数据，只不过比原来响应慢一点。\n  重试可以考虑切换一台机器来进行调用，因为原来机器可能由于临时负载高而性能下降，重试会更加剧其性能问题，而换一台机器，得到更快返回的概率也更大一些。\n幂等  在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。\n  幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。\n  这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。\n  例如： getUsername()和setTrue() 函数就是一个幂等函数. \n  更复杂的操作幂等保证是利用唯一交易号(流水号)实现.  我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的\n常见的幂等性解决方案  1. 查询操作： 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作  \n  2. 删除操作： 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)  \n数据库唯一索引，防止新增脏数据  比如： 新建用户的时候将手机号码设置为唯一索引，那么即使你重试，也只会新建一个用户，不会因为重试导致当前用户注册了两个用户\n  要点： 唯一索引或唯一组合索引来防止新增数据存在脏数据 当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）  \ntoken机制，防止页面重复提交\n业务要求：页面的数据只能被点击提交一次  \n\n发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交  \n\n解决办法：集群环境：采用token加redis（redis单线程的，处理需要排队） \n\n处理流程：  \n\n数据提交前要向服务的申请token，token放到redis或内存，token有效时间 \n提交后后台校验token，同时删除token，生成新的token返回\n\n\n\n  token特点： 要申请，一次有效性，可以限流  注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select + delete来校验token，存在并发问题，不建议使用\n悲观锁  获取数据的时候加锁获取 \n  select * from table_xxx where id&#x3D;&#39;xxx&#39; for update; \n\n  注意： id字段一定是主键或者唯一索引，不然是锁表，会死人的 \n  悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用  \n乐观锁  乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 \n  乐观锁的实现方式多种多样可以通过version或者其他状态条件： \n\n通过版本号实现 \n  update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where version&#x3D;#version# \n\n通过条件限制 \n  update table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where avai_amount-#subAmount# &gt;&#x3D; 0 \n\n  要求： quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高  \n  注意： 乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好 \n  update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where id&#x3D;#id# and version&#x3D;#version# \nupdate table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where id&#x3D;#id# and avai_amount-#subAmount# &gt;&#x3D; 0  \n\n\n分布式锁  还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，\n  这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，\n  这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 \n  要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)\nselect + insert  并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了  \n  注意： 核心高并发流程不要用这种方法  \n对外提供接口的api如何保证幂等  如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 \n  source + seq 在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求) \n\n\n\n\n\n\n\n\n\n重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。  \n总结：\n幂等与你是不是分布式高并发没有关系。关键是你的操作是不是幂等的。\n\n一个幂等的操作典型如：把编号为5的记录的A字段设置为0这种操作不管执行多少次都是幂等的。\n一个非幂等的操作典型如：把编号为5的记录的A字段增加1这种操作显然就不是幂等的。\n\n\n要做到幂等性，从接口设计上来说不设计任何非幂等的操作即可。\n\n譬如说需求是：当用户点击赞同时，将答案的赞同数量+1。改为：当用户点击赞同时，确保答案赞同表中存在一条记录，用户、答案。赞同数量由答案赞同表统计出来。\n\n总之幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，\n\n\n\n","slug":"micro-idempotence","date":"2023-01-11T06:16:21.000Z","categories_index":"Micro","tags_index":"微服务,幂等性机制,幂等性解决方案","author_index":"G"},{"id":"8dfd1c27e715ba69975506c84ee456c0","title":"CentOS8 安装 Docker Engine(Docker CE) 及 Docker Compose","content":"\n\n\n\n\n\n\n\n\n相关文档\nDocker 官方文档\nDocker Compose 版本发布页\n添加存储库dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo\n\n安装Docker包dnf install docker-ce docker-ce-cli containerd.io\n\n设置自启动systemctl enable --now docker\n\n防火墙规则CentOS 8 使用 Docker 以外的防火墙。因此，如果启用了 firewalld，则需要向其添加伪装规则。\nfirewall-cmd --zone=public --add-masquerade --permanent\nfirewall-cmd --reload\n\n手动安装 Docker Compose 二进制运行文件Docker 通常与 Docker Compose 一起安装。正是这个实用程序允许您使用一个命令将项目部署到另一台机器。要下载它，请运行以下命令：\ncurl -L \"https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/bin/docker-compose\nchmod +x /usr/bin/docker-compose\ndocker-compose version\n\n以非 root 用户身份使用 Docker为了能够以非 root 用户身份使用 Docker，您必须将该用户添加到 docker 组。\nusermod -aG docker username\n\n将用户名替换为所需的用户名。执行此命令后，他将需要退出系统并重新登录。注意！该组的用户可以控制 Docker 主机。\nDocker 测试容器运行您可以通过运行测试容器来验证 Docker 是否正常工作。\ndocker run hello-world\n\n\n\n","slug":"centos8-install-docker","date":"2023-01-11T04:10:02.000Z","categories_index":"Notes","tags_index":"Centos8,Docker,Docker Compose","author_index":"G"},{"id":"799caa19913ca1b7943f59953e293be8","title":"CentOS8 安装 pyenv 进行Python版本管理","content":"安装  pyenvcurl https://pyenv.run | bash\npyenv 基本命令# 查看pyenv命令\npyenv commands\n# 查看可安装的python版本\npyenv install --list \n# 查看已安装版本\npyenv versions \n# 查看当前使用的python版本\npyenv version \n# 安装python\npyenv install -v 版本号 \n# 刷新python已安装列表\npyenv rehash \n# 删除python\npyenv uninstall 版本号 \n# 设置当前全局python版本\npyenv global 版本号 \n# 设置局部python版本\npyenv local 版本号 \n# 取消局部python版本设置,或者删除当前目录下的.python-version文件\npyenv local --unset \n# help\n# pyenv help\n\n\n","slug":"centos8-install-pyenv","date":"2023-01-10T16:37:05.000Z","categories_index":"Notes","tags_index":"Centos8,Pyenv","author_index":"G"},{"id":"3c59ae176435d050b1c56ef81683320b","title":"CentOS8 中 dnf 命令的使用","content":"# 查看 `dnf` 的版本\ndnf --version\n# 查看软件库\ndnf repolist\ndnf repolist all\n# 查看 dnf 所有套件、目前已经安裝的套件、可用套件\ndnf list\ndnf list installed\ndnf list available\n# 查找套件、查看套件信息 （以套件 nginx 为例）\ndnf search nginx\ndnf info nginx\n# 卸载安装\ndnf remove nginx\n# 检查更新\ndnf check-update\n# 更新系統、更新套件\ndnf update\ndnf update nginx\n\n\n","slug":"centos8-dnf","date":"2023-01-10T10:33:49.000Z","categories_index":"Notes","tags_index":"Dnf,Centos8","author_index":"G"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nClean$ hexo clean\n","slug":"hello-world","date":"2022-08-14T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"G"}]
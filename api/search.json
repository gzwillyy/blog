[{"id":"07709a5ec8fca245e3ed20c42a15171e","title":"Mysql 之 使用 Prometheus 和 Grafana 监控 MySQL 性能","content":"\n\n\n\n\n\n\n\n\n请注意，这只是一个简单搭建教程，具体应用还需要根据实际情况来调整。\n基础环境\n\n\n环境&#x2F;组件\n版本\n\n\n\nMac M1虚拟机\nCentos8\n\n\nPrometheus\n2.41.0\n\n\nGrafana\n9.3.2\n\n\n1. Prometheus 安装与配置Prometheus 下载Prometheus 的官方网站https:&#x2F;&#x2F;prometheus.io\n\nPrometheus 安装Prometheus 安装的命令行语句cd ~\nmkdir prometheus &amp;&amp; cd prometheus\nwegt https://github.com/prometheus/prometheus/releases/download/v2.41.0/prometheus-2.41.0.linux-arm64.tar.gz\ntar -zxvf prometheus-2.41.0.linux-arm64.tar.gz\n./prometheus\n\n\n\n2. Grafana 安装与配置Grafana 下载Grafana 的官方网站https:&#x2F;&#x2F;grafana.com\n\nGrafana 安装Grafana 安装的命令行语句docker pull grafana&#x2F;grafana-oss:9.3.2-ubuntu@sha256:e76c86b351aadc13a748ac05937110a69d659b426ca59e0d824a325170ca75fd\ndocker run -d --net host --name&#x3D;grafana -e &quot;GF_INSTALL_PLUGINS&#x3D;grafana-clock-panel,grafana-simple-json-datasource&quot; -p 3000:3000 77a68ddee903\n\n3. mysql_exporter 安装与配置mysql_exporter 下载wget https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;mysqld_exporter&#x2F;releases&#x2F;download&#x2F;v0.14.0&#x2F;mysqld_exporter-0.14.0.linux-arm64.tar.gz\ntar -zxvf mysqld_exporter-0.14.0.linux-arm64.tar.gz\ncd mysqld_exporter-0.14.0.linux-arm64\nvim .my.cnf\n\n[client]\nhost&#x3D;127.0.0.1\nport&#x3D;3306\nuser&#x3D;mysqld_exporter\npassword&#x3D;mysqld_exporter\n\n.&#x2F;mysqld_exporter --config.my-cnf&#x3D;&#x2F;root&#x2F;prometheus&#x2F;mysql_exporter&#x2F;mysqld_exporter-0.14.0.linux-arm64&#x2F;.my.cnf\n\nvi &#x2F;root&#x2F;prometheus&#x2F;prometheus-2.41.0.linux-arm64&#x2F;prometheus.yml\n\n- job_name: &#39;mysqld-node&#39;\n    static_configs:\n    - targets: [&#39;192.168.1.235:9104&#39;]\n      labels:\n        instance: mysqld-node1\n\n\nGrafana 配置监控面板Grafana 中创建 mysql_exporter 监控面板导入mysqld_exporter仪表板 ID 7362 ,修改名称 加载\n\n","slug":"mysql-prometheus-grafana-build","date":"2023-01-22T13:58:26.000Z","categories_index":"Mysql","tags_index":"Prometheus,Grafana,监控","author_index":"G"},{"id":"8fee980f49138056ea0028cf01eac4d6","title":"微服务 之 高可用保障 - 链路追踪、熔断、限流、降级","content":"\n","slug":"micro-high-availability","date":"2023-01-12T08:40:29.000Z","categories_index":"Micro","tags_index":"链路追踪,熔断,限流,降级","author_index":"G"},{"id":"04abdce79ce1414cc92810e537b53ae4","title":"微服务 之 服务雪崩","content":"服务雪崩现象从服务雪崩开始讲起！假设存在如下调用链 :\nService A  -&gt;  Service B  -&gt;  Service C\n\n此时，Service A的流量波动很大，流量经常会突然性增加！\n\n那么在这种情况下，就算Service A能扛得住请求，Service B和Service C未必能扛得住这突发的请求\n\n如果Service C因为抗不住请求，变得不可用.那么Service B的请求也会阻塞，慢慢耗尽Service B的线程资源，Service B就会变得不可用\n\n紧接着，Service A也会不可用\n\n一个服务失败，终将会导致整条链路的服务都失败，我们称之为服务雪崩。\n那么，服务熔断和服务降级就可以视为解决服务雪崩的手段之一。\n服务熔断什么是服务熔断？\n\n\n\n\n\n\n\n\n\n服务熔断：当下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，        不再继续调用目标服务，直接返回，快速释放资源。        如果目标服务情况好转则恢复调用。        需要说明的是熔断其实是一个框架级的处理，那么这套熔断机制的设计\n服务降级这里有两种场景:\n\n当下游的服务因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，增加响应速度！\n当下游的服务因为某种原因不可用，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！\n\n可以这么理解:\n\n服务降级有很多种降级方式！如开关降级、限流降级、熔断降级! \n服务熔断属于降级方式的一种！\n\n\n\n\n\n\n\n\n\n\n可能有的人不服，觉得熔断是熔断、降级是降级，分明是两回事啊！其实不然，因为从实现上来说，熔断和降级必定是一起出现。\n因为当发生下游服务不可用的情况，这个时候为了对最终用户负责，就需要进入上游的降级逻辑了。\n因此，将熔断降级视为降级方式的一种，也是可以说的通的！\n撇开框架，以最简单的代码来说明！上游代码如下:\ntry&#123;\n    //调用下游的helloWorld服务\n    xxRpc.helloWorld();\n&#125;catch(Exception e)&#123;\n    //因为熔断，所以调不通\n    doSomething();\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意看，下游的helloWorld服务因为熔断而调不通。此时上游服务就会进入catch里头的代码块，那么catch里头执行的逻辑，你就可以理解为降级逻辑!\n\n\n\n\n\n\n\n\n\n服务降级大多是属于一种业务级别的处理。做法很简单，做个开关，然后将开关放配置中心！在配置中心更改开关，决定哪些服务进行降级。至于配置变动后，应用怎么监控到配置发生了变动，这就不是本文该讨论的范围。那么，在应用程序中部下开关的这个过程，业内也有一个名词，称为埋点！\n那接下来最关键的一个问题，哪些业务需要埋点？ \n\n简化执行流程 自己梳理出核心业务流程和非核心业务流程。然后在非核心业务流程上加上开关，一旦发现系统扛不住，关掉开关，结束这些次要流程。\n\n关闭次要功能 一个微服务下肯定有很多功能，那自己区分出主要功能和次要功能。然后次要功能加上开关，需要降级的时候，把次要功能关了吧！\n\n降低一致性 假设，你在业务上发现执行流程没法简化了，愁啊！也没啥次要功能可以关了，桑心啊！那只能降低一致性了，即将核心业务流程的同步改异步，将强一致性改最终一致性！\n\n\n这些都是手动降级，一般需要降级的场景，都是可以预见的，例如某某活动\n\n","slug":"micro-avalanche","date":"2023-01-12T06:45:02.000Z","categories_index":"Micro","tags_index":"服务雪崩","author_index":"G"},{"id":"9e30b559063f2ec93bec62f6225da283","title":"微服务 之 幂等性机制","content":"http请求的类型：\nget 获取商品信息， 这个会引起商品的数据的变化吗？\npost 比较常见，这种接口需要考虑到幂等性\nput\n没有幂等的问题的情况：把1号商品的价格改为200，网络返回的时候抖动了，重试 ,第二次接口还是会把1号商品的价格改为200 \n出现幂等性问题的情况：\n购物车中的商品，调用一次 这个商品的数量加一\n第一次调用 原本的值 10 之后价格变为11 - 但是返回的时候出现了网络抖动 \n第二次发送 原本的值 11 之后价格变为12 - 但是返回的时候出现了网络抖动，\n第三次发送 原本的值 12 之后价格变为13 - 但是返回的时候出现了网络抖动\n\n\n\n\ndelete 一般不具备幂等性的要求，第一次调用 删除数据，第二次调用 还是删除当前的数据\n\n\n\n\n\n\n\n\n\n\n现在假设，你自己开发了一个支付宝，然后别人在二维码支付页面，先支付了,结果由于网络问题，当前页面一直没有刷新，就让人以为我没有支付，然后我就再次扫码支付，这下完蛋了：你扣了两次款。\n超时 重试 幂等性机制超时  timeout是为了保护服务，避免consumer服务因为provider 响应慢而也变得响应很慢，这样consumer可以尽量保持原有的性能。\n重试  如果provider只是偶尔抖动，那么超时后直接放弃，不做后续处理，就会导致当前请求错误，也会带来业务方面的损失。\n  对于这种偶尔抖动，可以在超时后重试一下，重试如果正常返回了，那么这次请求就被挽救了，能够正常给前端返回数据，只不过比原来响应慢一点。\n  重试可以考虑切换一台机器来进行调用，因为原来机器可能由于临时负载高而性能下降，重试会更加剧其性能问题，而换一台机器，得到更快返回的概率也更大一些。\n幂等  在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。\n  幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。\n  这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。\n  例如： getUsername()和setTrue() 函数就是一个幂等函数. \n  更复杂的操作幂等保证是利用唯一交易号(流水号)实现.  我的理解：幂等就是一个操作，不论执行多少次，产生的效果和返回的结果都是一样的\n常见的幂等性解决方案  1. 查询操作： 查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作  \n  2. 删除操作： 删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)  \n数据库唯一索引，防止新增脏数据  比如： 新建用户的时候将手机号码设置为唯一索引，那么即使你重试，也只会新建一个用户，不会因为重试导致当前用户注册了两个用户\n  要点： 唯一索引或唯一组合索引来防止新增数据存在脏数据 当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）  \ntoken机制，防止页面重复提交\n业务要求：页面的数据只能被点击提交一次  \n\n发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交  \n\n解决办法：集群环境：采用token加redis（redis单线程的，处理需要排队） \n\n处理流程：  \n\n数据提交前要向服务的申请token，token放到redis或内存，token有效时间 \n提交后后台校验token，同时删除token，生成新的token返回\n\n\n\n  token特点： 要申请，一次有效性，可以限流  注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select + delete来校验token，存在并发问题，不建议使用\n悲观锁  获取数据的时候加锁获取 \n  select * from table_xxx where id&#x3D;&#39;xxx&#39; for update; \n\n  注意： id字段一定是主键或者唯一索引，不然是锁表，会死人的 \n  悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用  \n乐观锁  乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 \n  乐观锁的实现方式多种多样可以通过version或者其他状态条件： \n\n通过版本号实现 \n  update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where version&#x3D;#version# \n\n通过条件限制 \n  update table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where avai_amount-#subAmount# &gt;&#x3D; 0 \n\n  要求： quality-#subQuality# &gt;= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高  \n  注意： 乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好 \n  update table_xxx set name&#x3D;#name#,version&#x3D;version+1 where id&#x3D;#id# and version&#x3D;#version# \nupdate table_xxx set avai_amount&#x3D;avai_amount-#subAmount# where id&#x3D;#id# and avai_amount-#subAmount# &gt;&#x3D; 0  \n\n\n分布式锁  还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，\n  这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，\n  这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 \n  要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)\nselect + insert  并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了  \n  注意： 核心高并发流程不要用这种方法  \n对外提供接口的api如何保证幂等  如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 \n  source + seq 在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求) \n\n\n\n\n\n\n\n\n\n重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。  \n总结：\n幂等与你是不是分布式高并发没有关系。关键是你的操作是不是幂等的。\n\n一个幂等的操作典型如：把编号为5的记录的A字段设置为0这种操作不管执行多少次都是幂等的。\n一个非幂等的操作典型如：把编号为5的记录的A字段增加1这种操作显然就不是幂等的。\n\n\n要做到幂等性，从接口设计上来说不设计任何非幂等的操作即可。\n\n譬如说需求是：当用户点击赞同时，将答案的赞同数量+1。改为：当用户点击赞同时，确保答案赞同表中存在一条记录，用户、答案。赞同数量由答案赞同表统计出来。\n\n总之幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，\n\n\n\n","slug":"micro-idempotence","date":"2023-01-11T06:16:21.000Z","categories_index":"Micro","tags_index":"微服务,幂等性机制,幂等性解决方案","author_index":"G"},{"id":"8dfd1c27e715ba69975506c84ee456c0","title":"CentOS8 安装 Docker Engine(Docker CE) 及 Docker Compose","content":"\n\n\n\n\n\n\n\n\n相关文档\nDocker 官方文档\nDocker Compose 版本发布页\n添加存储库dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo\n\n安装Docker包dnf install docker-ce docker-ce-cli containerd.io\n\n设置自启动systemctl enable --now docker\n\n防火墙规则CentOS 8 使用 Docker 以外的防火墙。因此，如果启用了 firewalld，则需要向其添加伪装规则。\nfirewall-cmd --zone=public --add-masquerade --permanent\nfirewall-cmd --reload\n\n手动安装 Docker Compose 二进制运行文件Docker 通常与 Docker Compose 一起安装。正是这个实用程序允许您使用一个命令将项目部署到另一台机器。要下载它，请运行以下命令：\ncurl -L \"https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/bin/docker-compose\nchmod +x /usr/bin/docker-compose\ndocker-compose version\n\n以非 root 用户身份使用 Docker为了能够以非 root 用户身份使用 Docker，您必须将该用户添加到 docker 组。\nusermod -aG docker username\n\n将用户名替换为所需的用户名。执行此命令后，他将需要退出系统并重新登录。注意！该组的用户可以控制 Docker 主机。\nDocker 测试容器运行您可以通过运行测试容器来验证 Docker 是否正常工作。\ndocker run hello-world\n\n\n\n","slug":"centos8-install-docker","date":"2023-01-11T04:10:02.000Z","categories_index":"Notes","tags_index":"Centos8,Docker,Docker Compose","author_index":"G"},{"id":"799caa19913ca1b7943f59953e293be8","title":"CentOS8 安装 pyenv 进行Python版本管理","content":"安装  pyenvcurl https://pyenv.run | bash\npyenv 基本命令# 查看pyenv命令\npyenv commands\n# 查看可安装的python版本\npyenv install --list \n# 查看已安装版本\npyenv versions \n# 查看当前使用的python版本\npyenv version \n# 安装python\npyenv install -v 版本号 \n# 刷新python已安装列表\npyenv rehash \n# 删除python\npyenv uninstall 版本号 \n# 设置当前全局python版本\npyenv global 版本号 \n# 设置局部python版本\npyenv local 版本号 \n# 取消局部python版本设置,或者删除当前目录下的.python-version文件\npyenv local --unset \n# help\n# pyenv help\n\n\n","slug":"centos8-install-pyenv","date":"2023-01-10T16:37:05.000Z","categories_index":"Notes","tags_index":"Centos8,Pyenv","author_index":"G"},{"id":"3c59ae176435d050b1c56ef81683320b","title":"CentOS8 中 dnf 命令的使用","content":"# 查看 `dnf` 的版本\ndnf --version\n# 查看软件库\ndnf repolist\ndnf repolist all\n# 查看 dnf 所有套件、目前已经安裝的套件、可用套件\ndnf list\ndnf list installed\ndnf list available\n# 查找套件、查看套件信息 （以套件 nginx 为例）\ndnf search nginx\ndnf info nginx\n# 卸载安装\ndnf remove nginx\n# 检查更新\ndnf check-update\n# 更新系統、更新套件\ndnf update\ndnf update nginx\n\n\n","slug":"centos8-dnf","date":"2023-01-10T10:33:49.000Z","categories_index":"Notes","tags_index":"Dnf,Centos8","author_index":"G"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nClean$ hexo clean\n","slug":"hello-world","date":"2022-08-14T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"G"}]